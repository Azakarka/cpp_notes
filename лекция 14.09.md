# с чем кушают функции
Функции видят только те функции что заданы перед ними


Поэтому надо ее заранее задать:
```cpp
void foo1(); - объявление

void foo2() {
	foo1();
}

void foo1() { - определение
	foo2();
}
```


Когда объявляем можно не писать названия параметров, но это плохая практика
```cpp
void foo(int, long, unsigned);
```


>Правила функций:
> 1. делать одно дело и делать это хорошо
> 2. одинаковый уровень абстракции


```cpp
int main() {
	int value;
	cin >> value;
	cout << CalcFactorial(value) << endl;
}
так писать плохо
```

```cpp
void ReadInput() {
	cin >> sth;
}
void PrintResult(int val) {
	cout << val;
}

int main() {
	int input_value = ReadInput();
	int result = CalcFact(input_value);
	PrintResult(result);
}
этот код лучше, потому что нам все равно как мы получаем данные в main, ведь ввод данных может поменяться
```


# Const или не const и ссылки

```cpp
int main() {
	const int input_value = ReadInput(); // мы не меняем вал поэтому имеет смысл сделать ее константой
	int result = CalcFact(input_value);
	PrintResult(result);
}
```
> [!INFO] ИНФА
>const int - отдельный тип данных
>const никто не изменит - безопасность кода
>в const обычно записываетсю магические строчки/чиселки

В функцию передается ((очев)) копия объекта
```cpp
void foo(int mem) {
	mem = 10;
}

int main() {
	int mem = 3;
	foo(mem);
	cout << mem;
}
// выведет 3
```

Поэтому если тяжелый объект делаем амперсандик (ссылка):
```cpp
void foo(int& mem) {
	mem = 10;
}

int main() {
	int mem = 3;
	foo(mem);
	cout << mem;
}
// выведет 10
```

> [!INFO] ссылка
> int& - отдельный тип, но они оба указывают ну одну ячейку памяти 

очень круто будет если объединить ссылку и константу
> [!INFO] const string&
>Память мы можем читать, но менять не можем
>!!! всегда когда можем юзаем ее

>[!INFO] возврат функции
>Когда мы возвращаем что-то оно тоже копируется

```cpp
int& foo() {
	int mem = 10;
	return mem;
}
```

> [!WARNING] СТРАДАТЬ!!!!!!
> это нифига не сработает, потому что время жизни mem ограничено ее функцией, поэтому если мы вернем ссылку на мертвый объект, мы будет жестко страдать!!!!

```
int foo() {
	int mem = 10;
	return mem;
}
int main() {
	int  mem = foo(); // временный объект копируется в нормальный, после ";" временный умирает
	const int& mem = foo(); // так временный объект живет до конца скоупа
	int &mem = foo(); // не сработает, потому что временный храниться в регистре процесоора, а не в норм памяти, которую мы можем менять
	
}
```


```cpp

bool foo(int value, int& result) {
	if (value < 0) {
		return false;
	}
	if (value == 0) {
		result = 1;
		return true;
	}
	int prev_result = 0;
	if (!foo(value, prev_result))) {
		return false;
	}
	result = prev_result * value;	
}

int main() {
	int result = 0;
	if (foo(input, result)) {
		cout << result;
	} else {
		cout << "ты манки!!!!";
	}
	return 0;
}
```

# Указатели
```cpp

int main() {
	int input = -3;
	int* input_ptr = nullptr; // отдельный тип, чтобы инициализировать указатель
}
```
у каждой ячейке есть адрес, в какой-то ячейке лежит значение -3
если мы напишем так
```cpp
int* input_ptr = &input; // хранит адрес ячейки где лежит input

cout << *input_ptr; // а вот так печатаем значение по этому адресу
cout << input_prt; // выведет адрес, то есть большое странное число
```

> [!INFO] Константы
> И адрес и само значение могут быть константами
> const int* ptr = value // value мы потом менять можем, но не через указатель, указатель поменять можем
> int* cosnt ptr = value // адрес поменять уже не можем
> const int* const ptr = value;
> нельзя ни менять адрес ни объект (через него)

```
*intput_ptr = -4; // меняет значение
```


# Сложные векторы пошли все жопа

```cpp
int main() {
	vector vec = {1, 2, 3, 4}
	int* vector_begin = v.date(); // указатель на нулевой элемент
	
}
```

Указатель умеет:
1) ptr + int - адрес указателя, его шифтим на int * sizeof(element) (сдвиг указателя == взять по индексу)
2) ptr2 - ptr1 - количество элементов между двумя указателями (определена, если оба указателя на один непрерывный буфер указывают)

