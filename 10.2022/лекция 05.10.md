# линковка

> автор жестко скатал тему [отсюда](https://www.geeksforgeeks.org/internal-linkage-external-linkage-c/) и [отсюда](https://www.geeksforgeeks.org/understanding-extern-keyword-in-c/) - кому интересно можно глянуть ориг

> как мы уже знаем у компиляции две стадии: сначала каждый `cpp`-шник сам компилится, а потом все `cpp`-шники линкуются в одного павер-ренджера. 

> так вот, также мы знаем, что у каждой штуки есть своя область видимости, поэтому к примеру когда нам нужно написать что-то типа
```cpp
void foo1() {
	foo2();
}

void foo2() {
	foo1();
}
```

мы пишем так
```cpp
void foo2(); // вот эта штука называется объявление (declaration)

void foo1() {
	foo2();
}

void foo2() {
	foo1();
}

// то есть мы просто объявили, что такая функция есть, ты ее главное найди и компилятор находит, только уже немного ниже
```

> с линковкой примерно также...
```cpp
// к примеру у нас есть
test.cpp {
	
	int mem = 21;  
  
	void foo() {  
	    ++mem;  
	}
}

// и main.cpp в которой мы хотим увидеть эту глобальную переменную

// глобальная переменная - переменная объявленная вне какой-либо функции

// тогда если мы напишем что-то типа
main.cpp {
	int mem = 21;
	// или просто 
	int mem;

	int main() {
		std::cout << mem << std::endl;	
	}
}

// мы получим ошибку от линкера, что мы создали две переменные с одним именем

// потому что у нас одна и та же переменная в разных спп файлах нормально себе живут, но когда мы пытаемся связать их в один бинарник начинается борьба
```


> *Что же делать?*
> если вы знаете что такое global в питон, то это почти и есть оно
```cpp
// для этого в main.cpp объявим эту штуку ключевым словом extern

extern int mem;

int main() {
	std::cout << mem << std::endl; // выведет 21
}

// как и в примере с функциями, только теперь мы уже говорим линкеру: "иди ищи такую штуку в других единицах трансляции"

// а он и находит, он находит именно ту, что мы задали в test.cpp, а потом позволяет ее юзать уже в main.cpp
```

> !!! разницу между объявить и задать рекомендую понять из второй статьи, оставленной выше

> Есть два вида линковки:
> 1) внутреннее (`internal linkage`)
> 2) внешнее (`external linkage`)

> Только что мы видели пример с внешней линковкой, а именно:

```cpp
test.cpp {
	int mem = 21;  
}

main.cpp {
	int mem;
}
// такая штука не работает, потому что не константные глобальные переменные по дефолту внешние, получается что test.cpp и main.cpp переопределяют одну и ту же переменную

// эквивалетно написать в коде
int mem = 21;
int mem;
```


> Но мы можем "заглушить" одного из них при помощи внутренней линковки.
```cpp
test.cpp {
	static int mem = 21;  
}

main.cpp {
	int mem;
}

// ключевое слово static (в этом контексте) говорит, что эта переменная теперь находится только в локальной единице трансляции и никак вы ее получить извне не можете

// то же самое можно сделать и с main
test.cpp {
	int mem = 21;  
}

main.cpp {
	static int mem;
}

// или с обоими
test.cpp {
	static int mem = 21;  
}

main.cpp {
	static int mem;
}

// не суть - главное, что лишь одна единица орет на весь бинарник, что у нее есть такая переменная и никакая другая ей никак в этом не мешает

// по идее тут та же аналогия с разными скоупами и одними названиями переменных
int mem = 21;
{
	int mem = 23; 
}
```


## **константы**

> по дефолту для константных переменных используется внутреннее связывание

```cpp
// но мы конечно можем сделать так как мы хотим:

extern const int global = 21;
// так он будет искать эту константу в другой единице трансляции

// кому интересно: если в другом файле написать "extern int global;" и потом его пытаться изменять вылезет стремная ошибка
```



## **namespace**

> `namespace` дословно пространство имен, то есть место где лежат разные именна переменных, функций и прочего.

```cpp
namespace lecture {
	void Print(string s);
}
// вызывать функцию принт вне namespace можно как lecture::Print(s)

// вообще все фукнции у нас в глобальном namespace

// то есть обычную функцию
void foo(){
}

//можно вызвать как
::foo();
```

> Зачем `namespace` нужен?
> 
> ну чтобы решать классическую проблему нехватки имен
> 
> к примеру `namespace std`, в котором есть свои классы и функции, 
> а мы хотим написать свои классы и функции с такими же именами,
> тогда чтобы имена не пересекались `std`-шные штуки зовем через std::, а свои по-обычному (или тоже в `namespace` кинем)

```cpp
// namespace могут быть вложены

namespace lecture{
	void Print(string s) {
		std::cout << str << std::endl;	
	}
	namespace utils {
		void Foo() {
		}
	}
}

// из функции принт мы можем вызвать foo двумя способами: 
// 1) абсолютным lecture::utils::foo
// 2) относительным utils::foo


// функции более высокого уровня видно без каких-либо ::
void Foo() {
	Print();
}
// но лучше писать абсолютный путь, так код будет намного читабельнее
```

```cpp
// вложенные namespace не обязательно хранить внутри основного:
namespace lecture{
	...
}
// вот написали отдельно)
namespace lecture::utils {
	...
}
```

> части namespace можно писать в разных `.h` и `.cpp` файлах 

## **Анонимный namespace** 
```cpp
namespace { // анонимный == не имеет названия
}
// все символы внутри анонимного "namespace" внутренне связаны, то есть просто замена "static"

// это удобно в том, что можно все "static" штучки кинуть туда
```

> то есть в `.h` файл мы пишем интерфейс (объявление всех классов, функций, методов и прочего) в `.cpp` их реализацию, а в `namespace` в `cpp`-файле уже все, что нужно для этой самой реализации.

```cpp
// когда мы пишем такое вот чудо

using namespace lecture;

// в наш текущий скоуп кидаются все символы(названия элементов) из lecture

// но так по прежнему останутся проблемы с названиями и прочим, так что есть ли смысл?
```


### **static function**
> мы уже поняли что будет если переменная будет иметь внутреннюю связку, что насчет функций?
```cpp
// вообще все функции изначально extern

// соотвественно если мы напишем
static void foo(); 
// она будет видна только в локальной единицы, а значит в разных единицах она может делать разное



// самое прикольное, что в .h файле можно написать
static void foo();
// а потом (заинклюдив .h) сделать свою реализацию "foo()" в каждом из cpp файлов

// но думаю так делать не стоит)
```

inline

> *рекомендует* (не приказывает) компилятору поставить тело функции в место вызова, то есть:
```cpp
void foo() {
	std::cout << "memes" << std::endl;
}

int main() {
	foo();
}

// если компилятор решит заинлайнить, полчучим:

int main() {
	std::cout << "memes" << std::endl;
}
```

> опять таки мы только *рекомендуем*, компилятор сам решит заинлайнить что-то или нет, независимо от ключевого слова `inline`


# **Память**

> плюсы вообще низкоуровневый язык, потому что имеется прямой доступ к памяти

## **Автоматическая**

> первый вид память - автоматическая, или стек

> в ней хранятся все локальные переменные
```cpp
int x = 1; // в автоматической

void Foo(int v) { // v - автоматическая память
	
}
```

> автоматическая память представляет из себя стек, какое-то ограниченное место в памяти, где все переменные хранятся последовательно

> соотвественно при создании переменной, она кидается в стек, после выхода из скоупа удаляется с конца (стек же). 

> работа с стеком дешевая, и добавление и удаление.

> удалить руками локальную переменную не можем, только позвать деструктор

```cpp
// вот как пример
int x = 1;
int y = 2;
int z = 3;
std::cout << &x << " " << &y << " " << &z << std::endl;
// можно увидеть, что они лежат подряд
```

> как уже было оговорено, стек ограничен по размеру, в момент вызова функции выделяется какой-то кусок памяти, если схавать больше будет `stackoverflow`

> с помощью комманды `ulimit -a` можно найти размер стека (у меня почти 8мб)

> получаем что жизнь переменных жестко привязано к времени жизни скоупа


## **Статическая**

> в ней живут в том числе глобальные переменные мы их изначально знаем, поэтому компилятор заранее выделит область памяти для них

> глобальные переменные уже инициализированны


```cpp
void Foo() {
	static int counter = 0;
	// такие тоже лежат в статической памяти
	// когда мы в первый раз заходим в Foo() у нас создается эта переменная, второй раз она уже не инициализируется
}

// по сути это глобальная переменная, но видят ее только в функции
```

```cpp

static int global = 21;
// ничего общего с статической памятью не имеет, глобальная переменная и без static будет с статик памяти
// тут статик влияет только на линковку между единицами трансляции
```

> время жизни - время исполнения всей программы

## **Динамическая**

```cpp
int* int_ptr = new int;
// оператор new позваляет выделить память в "куче"
```

> куча умеет быстро искать кусок свободной памяти какого-то размера

> есть разные алгоритмы реализации кучи, но в любом случае сталкиваешься с фрагментацией

> фрагментация - ситуация когда между занятыми кусками памяти лежат маленькие незанятые, которые никому не нужны

> чисто теоретически может быть занят каждый второй байт, то есть занято всего лишь половина всей памяти, но объект больше 1 байта вставить не получится

> выделение памяти на куче тяжелая штука, зато мы можем взять любой кусок памяти, пока конечно это физически возможно


```cpp
int* int_ptr = new int(10);
// синтаксис работы с динамической памятью

// аналогично можно вызывать конструктор и для других типов

// вот вам и кастомный класс
Printer* ptr = new Printer("hi");
ptr->Print();
```

### **трубочист - хорошая работа**

> динамическая память сама чиститься не будет

```cpp
// для этого пишем
delete ptr;

// он сначала вызовет деструктор, а потом очистит эту память

delete ptr; // очистил память
// второй раз пишем
delete ptr; // undefined behaiour, так как память уже очищенаы
```

> близнец-массив

```cpp
int* ptr = new int[10];
delete[] ptr;
// такая штучка нужна для удаления массива из ValueType

// если вызвать delete[] от обычной переменной будет undefined behaviour и наоборот тоже
```

> !!! Если не чистить память, она может закончится (утечка памяти) и реюзануть не получится

> вопрос на засыпку

```cpp
	std::vector<int> v (1'000'000'000); // 4 гб
	// будет ли такое работать, если стек всего 8мб?





	// да, потому что vector в автоматической памяти хранит инфу про себя
	// массив с элементами же он хранит в динамической
```