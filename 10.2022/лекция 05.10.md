## **глобальные переменные**

Начем с глобальных переменных, то есть с тех, что лежат вне каких-либо функций.
```cpp
int global = 21;
```
В рамках одного 

Видеть глобальные переменные можно с помощью 
```cpp
extern int global;
```
обычно это пишут в .h 

```cpp
static int global;
так она будет только внутри одной штуки
```


## **константы**
Для констант применяется внутренее связывание 

```cpp
extern const int global;
он будет брать значение из другой единицы траснляции
```

что такое namespace

```cpp

namespace lecture {
	void Print(string s);
}

namespace это просто пронстранство имен, то есть место где лежат разные именна переменных функци и прочего.

вообще по дефолту у нас глобальный namespace

то есть обычную функцию
void foo(){

}

можно вызвать как
::foo();
```

```cpp
namespace могут быть вложены

namespace lecture{
	void Print(string s) {
		cout << str << endl;	
	}
	namespace utils {
		void Foo() {
		}
	}
}

из функции принт мы можем вызвать foo двумя способами: абсолютным lecture::utils::foo и относительным utils::foo

Функции более высокого уровня видно без каких-либо ::
void Foo() {
	Print();
}
но если хотим можем написать абсолютный путь
```

```cpp
namespace lecture{
	...
}

namespace lecture::utils {
	...
}
можно разделять вот так
```

Части namespace можно писать в разных .h и .cpp файлах 


Для чего надо?
1) ограничить область видимости
2) имена не пересекались, функций типа Print дофига

## **Анонимный namespace** 
```cpp
namespace { // не имеет названия
}
все символы внутри анонимного namespace внутренне связаны, то есть просто замена static

это удобно в том, что можно все static штучки кинуть туда
```

В .h файле пишется интерфейс, в .cpp файле реализация, а вот в namespace уже все что нужно для реализации

```cpp

using namespace lecture;

в наш текущий скоуп кидаются все символы из lecture
```
но так у нас вернутся все проблемы с названиями и прочим

функции можно делать static
```cpp
то есть конкретно для этого файла делается по-своему
```

inline
```cpp
говорит компилятору что можно вставить тело этой функции в месте где мы вызываем

//TODO
```


```cpp

Пишем в .h файле нашу штуку

class Printer{
public:
	Printer(const std::string& str);
	void Print() const;
private:
	stdLL::string str_;
}
```

```cpp
в .cpp файле уже делаем
	void Print() const{
		...
	}
это уже знакомо
```


а что с static переменной?
```cpp

\\ out of line реализация
class Printer{
public:
	Printer(const std::string& str);
	void Print() const;
private:
	stdLL::string str_;
	static int var;
}

а в .cpp
int Printer::var = 1;
```

С 17 плюсов
```cpp
class Printer{
public:
	Printer(const std::string& str);
	void Print() const;
private:
	stdLL::string str_;
	inline static int var = 1;
}

Потом она просто будет вставляться куда надо
```

```cpp
const static int var = 1;
не нужен inline, но для сложных объектов понадобится out-of-line
```




низкоуровневый язык потому что имеется прямой доступ к памяти
```cpp
первый вид памяти это автоматическая
int x = 1; то есть все локальные переменные

void Foo(int v) { // v - автоматическая память
	
}
```

у нас есть какой-то стек, на котором выделяется место для наших переменных

Работа с стеком очень дешевая, так как они хранятся последовательно, в заранее выделенной памяти, удалять тоже очень дешево.

Удалить руками локальную переменную не можем, только позвать деструктор

```cpp
int x = 1;
int y = 2;
int z = 3;
cout << &x << " " << &y << " " << &z << endl;
можно увидеть, что они лежат подряд
```

Стек ограничен по размеру, в момент вызова функции выделяется какой-то кусок памяти

ulimit -a можно найти размер стека

время жизни локальных переменных жестко привязано к существовании функции



статическая память

в ней живут глобальные переменные мы их изначально знаем, поэтому компилятор заранее выделит область памяти для них

глобальные переменные уже инициализированны


```cpp
void Foo() {
	static int counter = 0;
	такие тоже лежат в статической памяти
	когда мы в первый раз заходим в Foo() у нас создается эта переменная, а потом это уже не выполняется
}

по сути это глобальная переменная, но видят ее только в функции
```

```cpp
Printer printer("hello");

int main{}

printer создастся до захода в main и удалится после выхода из main

время жизни статических переменных, то это время жизни всей программы
```

```cpp

static int global = 10; 
ничего общего с статической памятью не имеет, глобальная и без static будет с статик памяти
тут статик влияет только на линковку между единицами трансляции
```



динамическая память

```cpp
int* int_ptr = new int;
оператор new позваляет выделить память в "куче"

куча умеет быстро искать кусок свободной памяти какого-то размера

есть разные алгоритмы:
к примеру
1) первый свободный
2) берет максимально похожий 

как не тяжело понять у нас могут быть жесткие проблемы с фрагментацией

выделение памяти на куче тяжелая штука, зато мы можем взять любой кусок памяти, пока конечно это физически возможно
```

```cpp
int* int_ptr = new int(10);

аналогично можно вызывать конструктор и для других типов

Printer* ptr = new Printer("hi");
ptr->Print();
```

память сама не очистится
```cpp
для этого пишем
delete ptr;

он сначала вызовет деструктор, а потом очистит эту память

delete ptr; // очистил память
delete ptr; // undefined behaiour, так как память уже очищенаы
```


близнец-массив
```
unt* ptr = new int[10];
delete[] ptr;

если вызвать delete[] от обычной переменной будет undefined behaviour и наоборот тоже
```

что если
```cpp
	std::vector<int> v (1'000'000'000); // 4 гб
	живет в автоматической памяти 

	как он поместился на stack?

	сам вектор маленький, он хранит там size и все такое, сами же элементы вектора хранятся в heap, а потом переопределяется размер есчо
```