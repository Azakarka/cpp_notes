
## **strong-exception guarantee


```cpp
// пусть у нас есть какой-то класс стринг, который хранит в себе собственно строку
class String{
	...
	private:
	char* data_;
}

// очевидно, что мы хотим написать оператор присваивания, чтобы все хорошо работало
String& operator=(const String & other) {
	if (this == &other) {
		return *this;
	}
	data_ = new char[other.size_];
	size_ = other.size_;
	std::memcpy(data_, other.data_, size_); // просто сделает deepcopy содержимого
}
```

```cpp
// теперь разберем пример на ошибки
// 1) заметим что мы получаем MemoryLeak, поэтому
String& operator=(const String & other) {
	...
	delete[] data_; // удаляем занятую память
	data_ = new char[other.size_]
	...
}
// ведь так как у нас оператор присваивания, у нас уже есть какой-то существующий объект, а значит и выделенная память
// поэтмоу ее очищаем

```

```cpp
// 2) собственно представим, что у нас не выделилась память, тогда
String& operator=(const String & other) {
	...
	delete[] data_; // мы очистили объект
	data_ = new char[other.size_]; // тут упало bad::alloc
	...
}
// итого: объект испорчен
// почти всегда, если вылезает какая-то ошибка ее можно исправить, поэтому важно сохранить нормальное состояние
```

```cpp
// можно заменить эту лажу вот таким кодом
String& operator=(const String & other) {
	...
	auto* tmp = new char[other.size_];
	delete[] data_;
	data_ = tmp;
	...
}
// получили: если ловим bad::alloc, вылезаем из метода с нормальным, неизмененным состоянием
// если bad_alloc не ловим, то все нормально проходит
```


# *RVO*
```cpp

// напишем простенький код

String MakeString(const char* str) {
	return String(str);
}

int main() {
	std::cout << MakeString("world") << std::endl;
}
// что мы ожидаем увидеть?
// 1) Constructor от str в MakeString
// 2) Copy Constructor временного объекта из функции в временный объект из main
// 3) Destructor от временного объекта в функции
// 4) Destuctor от временного объекта в main

// тут вступает в силу RVO - return value optimization
```

> RVO - механизм исключения копий

она заключается в том, что если тип возвращаемого объекта совпадает с типом возвращаемого объекта функции(const тоже подходит), то копирка не произойдет: временный объект функции не будет создаваться, а сразу запишется.
```cpp
// то есть код выше эквивалентен
void MakeString(const char* str, String &res) {
	res = String(str);
}

int main() {
	String result; // причем код не будет полностью эквивалентен, так как тут вызовется пустой конструктор
	MakeString("world", result); 
	std::cout << result << std::endl;
}
```

```cpp
// даже такой код юзанет RVO, хотя result уже не временный, а именной
String MakeString(const char* str) {
	String result(str);
	return result; // NRVO на самом деле
}

int main() {
	std::cout << MakeString("world") << std::endl;
}
```


другой пример
```cpp

String str = String("hello");
// Опять таки что ожидаем?
// 1) Конструктор от стринга
// 2) Конструктор от другого стринга
// 3) оператор присваивания 
// 4) деструктор от временного стринга

// тут работает еще один механизм copy-elision

// если мы инициализируем один объект типа T временным объектом типа T, копирования не происходит

String str = String(String("hello")); // и такое тоже сработает
```


третий пример
```cpp
void PrintString(String str) {
	std::cout << str << std::endl;
}

int main() {
	String str("hello");
	PrintString(str);
}
// так произойдет конструктор копирования в функцию PrintString

// если заменить объект на временный
PrintString(String("hello"));
// уже никаких лишних копирок не будет, объект просто уже создастся в самой функции, не создаваясь в main
```

> [!WARNING] Важно
> copy-elision работает только если типы объектов совпадают
> с неявно приводящимися не работает так 



# *Move-semantics*

```cpp
// NRVO тут на самом деле, в отличие от RVO, не обязателен
// компилятор будет использовать его по своему усмотрению
// RVO - обязательство
String MakeString(const char* str) {
	String result(str);
	return result; // NRVO
}

int main() {
	std::cout << MakeString("world") << std::endl;
}

// если NRVO не будет использоваться, у нас получается result копируется в main, а потом навсегда удаляется
// хочется что-то сделать с этим
```

В чем идея move семантики?

Если мы знаем, что какой-то объект больше не будет использоваться, вместо честного копирования можно использовать читы, а именно просто украсть все, что есть у этого объекта

То есть сделать shallow copy.

```cpp
// демонстрация функции, когда у нас не выполнится NRVO
String MakeString(String result) {
	return result;
}

int main() {
	std::cout << MakeString(String("hello")) << std::endl;
}
// дествительно String("hello") он сразу кинет в стек функции, но при выводе уже сделает копию
// мы хотим это доп копированию соптимизировать
```

для реализации move семантики у нас есть два метода в классе

## **move contsructor**
или мув конструктор копирования
```cpp
class String{
	String (String&& other) { // такой тип называется rvalue reference, спец ссылка для временных объектов
		// other это объект который мы не будем больше использовать
		data_ = other.data_;
		size_ = other.size_;
		// так как other вот-вот удалится, не забываем его обнулять, а то наши указатели будут на пустоту указывать
		other.data_ = nullptr;
		other.size_ = 0; // по приколу
	}
}

// теперь взнлянем на то как все поменялось
String MakeString(String result) {
	return result;
}

int main() {
	std::cout << MakeString(String("hello")) << std::endl;
}
// вместо 
// 1) создать "hello" в MakeString
// 2) копировать его в main
// 3) удалить локальную переменную функции

// получаем
// 1) создать "hello" в MakeString
// 2) move-копировать его в main
// 3) удалить пустой объект
```


## **move присвавание**

мозг еще не лопнул? продолжаем!
```cpp
String hello("hello");
String world("world");
String hello_world;
hello_world = hello + world;

// поймем что тут происходит
// 1) создается hello
// 2) создается world
// 3) создается дефолтно hello_world
String operator+(const String& other) const {
	String result; // 4) создается вот это
	...
	return result; // тут сработало NRVO, он стал теперь hello + world
}
// 5) у нас hello_world = временный объект, получаем просто копирку, так как вызвался оператор присваивания


// напишем move оператор присваивание чтобы не копировать на последнем шаге 
String& operator=(String&& other) {
	if (this -- &other) { // да этот if нужен, так как можно сделать так, чтобы объект сам с собой мувался
		return *this;
	}
	// чистим нашу старую штуку
	delete[] data_;
	// воруем "кишки" other
	data_ = other.data_;
	size_ = other.size_;
	// не забываем занулить other
	other.data_ = nullptr;
	other.size_ = 0;
	return *this;
}	

// теперь пункт в пункте 5 будет не обычный оператор присваивания, а мувный

// сэкономили
```

```cpp

// небольшое разъяснение
String hello_world;
hello_world = hello; // запустит какой оператор????


// правильно НЕ мувный, потому что hello - именная переменная и вроде пока умирать не собирается

// а если hello нам больше не пригодится? 

// для этого есть std::move

// понимать нужно то, что эта функция сама ничего не мувит, никак вообще ничего не трогает
hello_world = std::move(hello); // move - по сути своей cast

// то есть просто cast String к String&&
// теперь получается уже запустится move operator=

// никто кст не машает делать так, так что тот ифик не забываем
hello = std::move(hello);
```

намусорил и радуется 😔😔😔
```cpp
// чуток почистим код
String& operator=(String&& other) {
	if (this -- &other) {
		return *this;
	}
	delete[] data_; // фу удалять
	
	data_ = other.data_; // фу присваивать
	size_ = other.size_; 
	
	other.data_ = nullptr; // а потом присваивать опять
	other.size_ = 0; // по факту тут вообще деструктор просто вызывается
	
	return *this;
}

// крч не нравится нам
// попробуем заменить на свапы
String& operator=(String&& other) {
	std::swap(data_, other.data_);
	std::swap(size_, other.size_);
	return *this;
}	
// думаю всем понятно почему это сработает

// при передаче того же объекта свап ничего не сделает ОК

// при передаче другого объекта мы возьмем его кишки ОК

// старая память очистится (возможно не сразу конечно, но) ОК
// p.s. так как вызовется конструктор от other, в котором старая память и очистится


// ну просто ляпота же!
```

ты думаешь мы собирались останавливаться?????

оооо нет!!!!
## *магия*
```cpp
// гениальная мысль а давайте эти вот амперсандики удалим, ну не нравится они нам!
String& operator=(String&& other) {
	std::swap(data_, other.data_);
	std::swap(size_, other.size_);
	return *this;
}
// превращаем в
String& operator=(String other) {
	std::swap(data_, other.data_);
	std::swap(size_, other.size_);
	return *this;
}
// и не забудем удалить уже написанный обычный оператор присваивания

// если у нас было обычное
hello_world = hello; // то есть именной не временный объект
// то мы его один раз скопируем при входе в функцию и потом просто возьмем от него значение
// количество копирований осалось прежним (1)

// если у нас передается временный объект, то через copy-elision у нас все хорошо без копироний сделается
// количество копирований такое же (0)

// если у нас передавалось &&, то он у нас воспринимается как временный, так что опять таки
// 0 копирований


// в каждом случае у нас программа будет работать также при таком коде

// зато какой простой и читаемый код мы получили!
```
такая штука называется copy and swap

плюсом ее еще является то, что сохраняется strong-exception guarantee, ошибок то выкинуться не может

## **Аналогичный прием**

```cpp
class Foo() {
public:
	Foo(const std::string& str) : str_(str) {}
}

private:
	std::string str_;
}
// обычный класс

// напишем
Foo(const std::string&& str) : str_(str) {}
// чтобы мы могли передавать временные строчки без лишней копирки

// а замечаем что? правильно, можно просто написать
Foo(std::string str) : str_(std::move(str)) {}

// заметим, что оно будет работать также как и два предыдущих конструктора в сумме
```

ну не фантастика ли, а?


## **move constructor**

да опять да снова

вообще говоря move конструктор создатся так же автоматически как и дефолтный copy конструктор

соотвественно если в copy просто все поля копируются, то в move все поля муваются

Но есть ряд условий, при которых дефолтный move конструктор не будет создан(хотя бы одно из):

1) кастомный copy конструктор
2) кастомный оператор присваивания
3) кастомный move конструктор <-> не сгенерит кастомный move оператор
4) кастомный деструктор

то есть да просто "правило 5", если хоть что-то понадобилось, значит понадобится все


еще конечно дефолтный мув конструктор не будет создан, если какое-то поле нельзя ни замувить ни копировать

и еще всякие случаи (ДЗ ПРОЧИТАТЬ ЗАВТРА ВСЕМ РАССКАЗАТЬ)


```cpp
Foo(std::string str) : str_(std::move(str)) {}

// когда мы пишем std::move() мы не знаем есть ли у класса move конструктор
// если его нет не выведется никакая ошибка, просто вместо move будет использоваться copy

// поэтому такая реализация конструктора по прежнему бесподобна
```