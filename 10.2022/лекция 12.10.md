
```cpp

Div(a, b)

double Div(double a, double b) {
	return a / b;
}
```

как выдать ошибку?
```cpp
	
double Div(double a, double b) {
	if (abs(b) < 0.0001) {
		return Nan;
	}
}
```

```cpp
double Div(double a, double b, bool& success) {
	if (abs(b) < 0.0001) {
		success = false;
		return 0;
	}
	success = true;
	return a / b;
}

int main() {
	bool success = false;
	double result = Div(1, 2, success);
	if (success) {
		// do sth
	}
}
много ненужного кода
```


ИСКЛЮЧЕНИЯ

мы можем кинуть исключение
```cpp
double Div(double a, double b, bool& success) {
	if (abs(b) < 0.0001) {
		throw 1;
	}
	success = true;
	return a / b;
}
можно кинуть любое, но лучше кидать старндартные
throw std::exception();
```
что происходит?

функция выводит ошибку, пока ошибка не поймается

вызывается деструктор локальных переменных


как обрабатывать?

```cpp

try{
	std::cout << Div(5, 0);
} catch(...) {
	std::cout << "Error";
}


catch(...) - ловит все исключения


catch(const std::exception& e) {
	std::cout << "Got std::excpetion";
}
исключения обычно ловятся по const &, чтобы не создавалась копия объекта. менять его тоже обычно не надо.

Также ссылка нужна для полиморфизма, чтобы наследуемые челики тоже ловились.

блоки пытаются применится в том порядке, в котором написаны

если не поймать исключение, иключение будет выходить из функций пока не найдет то, что его ловит, пока не выйдет из main, после чего программа закончит работу.
```

```cpp
double Div(double a, double b, bool& success) {
	if (abs(b) < 0.0001) {
		throw std::out_of_range("error");
	}
	success = true;
	return a / b;
}

int main() {

		catch(const std::exception& e) { // из-за полиморфизма вызовется вот это
		
	} catch (const std::out_of_range &e){
	
	} 
}

если мы хотим перебросить исключение дальше, можно написать 
throw; - это кинется ошибку на уровень выше
```


```cpp
исключение в конструкторе

struct Foo() {
	Foo() {
		ptr = new int(10);
		throw std::exception;
	}
	private:
	int* ptr = nullptr;
};
декструктор класса вызван не будет, так как он не считается созданным
```

```cpp

struct Foo() {
	Foo() {
		ptr1 = new int(10);
		ptr2 = new int(10); // если вызовет bad::alloc, надо что-то сделать с ptr1
		// поэтому используем умные указатели
	}
	private:
	int* ptr1 = nullptr;
	int* ptr2 = nullptr;
};
```


когда у нас выбрасывается исключение, он начинает запускать деструкторы, если и оттуда вылезет исключение, то не понятно как это обрабатывать, поэтому такая штука Undefined Behaviour

ptr1 = new(std::noexcept) int(10);



```cpp
class Foo() {
void Do() noexcept // или throw() {

}
}
noexcept говорит что такой метод не может выбрасывать никакие исключения

проблема в том что это обрабатывается на этапе работы

если эта функция выкинет исключение, это приведет к аварийному завершению программу

так как даже на этапе компиляции это не обрабатывается, это чисто маркер для разработчиков.
```



СТАТИЧЕСКИЙ ПОЛИМОРФИЗМ
```cpp

int Sub(int a, int b) {
	return a - b;
}

int main() {
	std::cout << Sub(10, 5) << std::endl;
}

хотим такие же для даблов
double Sub(double a, double b) {
	return a - b;
}

std::cout << Sub(3.5, 1.25) << std::endl;


если пытаемся вызвать один от инта другой от дабла, то вызов не понятный, так как двузначно можно неявно кастануть к обеим функциям
можно написать static_cast, чтобы этого избежать
```

> overload resolution - процесс разрешение вопроса какую фунцию нужно выбрать
> можно почитать на cppreference

если писать такое для всех типов это не очень приятно

пишем шаблоны...

```cpp
template<typename T>
T Sub(T a, T b) {
	return a - b;
}

этот T можно использовать как какой-то тип

когда мы вызываем нашу функцию Sub() от двух интов, он проверят если это два одинаковых типа, то идем дальше

если это инт, то компилятор за нас генерит Sub() от интов, если бы мы передали double он бы генерил функцию от double

на каждый запускаемый тип компилятор сам сгенерит функция, причем на каждой вызов уже сущесвтующая функция не создается заново

соотвественно если мы ни разу не вызовем функцию, компилятор просто не будет ее создавать, в бинарном коде даже такого нет

Подводные? Если не делать тесты на свой шаблон, может выйти лажа, так как компилятор не проверяет код внутри шаблона, если шаблон для каких-то типов не создается.

Sub(10.0, 5);
он не может понять что делать, так как T может быть как double так и int


Sub<double>(10.0, 5);
мы сам задали, что T - double и он уже нормально отрабатывает
```


```cpp
int arr[10] = {0};
std::cout << Sub(&arr[0], &arr[1]) << std::endl;
выдаст ошибку, потому что разность указателей дает не тот же тип что и они сами, а именно difference_type

template<typename T, typename R>
R Sub(T a, T b) {
	return a - b;
}

теперь уже надо явно указать что нам нужно выветси
Sub<int*, std::ptrdiff_t>(&arr[0], &arr[1]);
не очень приятно


попробуем поменять местами
template<typename R, typename T>
R Sub(T a, T b) {
	return a - b;
}
в шаблонах можно опускать типы, если компилятор может понять какой тип нам нужен

или можно сделать так

template<typename R, typename T = int>


опускать шаблонные параметры можно только на суффиксе, поэтому можно написать
Sub<std::ptrdiff_t>(&arr[0], &arr[1]);


тут можно вывести auto, если очень хочется упростить код, не надо забывать что все ретурны должны вывести тип



template <typename T>
auto Sub(T a, T b) 
	R result; // = a - b
	result = a - b;
	return result;
}


decltype на этапе компиляции опеределяет тип выражения, это выражение выполнятся не будет
то есть можно написать даже лажу, которая выбросит исключение, к примеру выход за границу

но опять таки сама штука запускаться не будет, только узнает ее тип
decltype(a - b) result;


для большей уверенности
declval - возвращает ссылку на фиктивный объект, потом вызвать оператор или еще чего
decltype(std::declval<T>() - std::declval<T>());


вместо typename можно писать class, это просто названия
```

```cpp

tempale<int N, typename T>
auto Sub(T a, T b) {
	return a - b + N;
}

std::cout << Sub<100>(10, 2); // какой-то мем, выведет 108

к примеру это релизовано для std::array, чтобы с точки зрения языка C++ массивы разных размеров были разными классами.
std::array<int, 100> a;
```

есть шаблонные переменные глобальные


есть шаблонные классы
```cpp
template <typename T>
class UniqPtr {
public:
	explicit UniqPtr(T* ptr) : ptr_(ptr){};

	T& operator*() {
		...
	}

	T* operator->() {
		...
	}

	~UniqPtr() {
		delete *ptr_;
	}

private:
	T* ptr_ = nullptr;
}


int main() {
	UniqPtr<int> ptr(new int(123));
	std::cout << *ptr << std::endl;
}
можно не указывать тип, если компилятор понимает что мы передаем

UniqPtr ptr(new int(123)); в конструкторе явно понимается что есть T

если написать к примеру пустой конструктор и его запускать, то это уже не сработает


UniqPtr<int> ptr(new int(123));
UniqPtr<double> ptr(new int(123));
создатся два класса: для int и double
```

```cpp

template <typename T>
class UniqPtr {
public:
	explicit UniqPtr(T* ptr) : ptr_(ptr){};

	T& operator*() {
		...
	}

	T* operator->() {
		...
	}

	template<typename R>
	R Cast() const {
		return static_cast<R>(*ptr_);
	}

	~UniqPtr() {
		delete *ptr_;
	}

private:
	T* ptr_ = nullptr;
}

методы генерятся отдельно от класса, так как не понятно какой передавать
```


```cpp
специализация

auto Sub(std::string a, std::string b) {
	return a.size() - b.size();
}


template <>
auto Sub<std::string>(std::string a, std::string b) {
	return a.size() - b.size();

этот шаблон полная специализация более общего шаблона и идти должна позже

конкретно в этом случае можно было и просто фукняи бахнуть


на классах интереснее

к примеру 


template <typename T>
class UniqPtr {
public:
	explicit UniqPtr(T* ptr) : ptr_(ptr){};

	T& operator*() {
		...
	}

	T* operator->() {
		...
	}

	template<typename R>
	R Cast() const {
		return static_cast<R>(*ptr_);
	}

	~UniqPtr() {
		delete *ptr_;
	}

private:
	T* ptr_ = nullptr;
}


template <typename T>
class UniqPtr<T[]> {
public:
	explicit UniqPtr(T* ptr) : ptr_(ptr){};

	T& operator*() {
		...
	}

	T* operator->() {
		...
	}

	template<typename R>
	R Cast() const {
		return static_cast<R>(*ptr_);
	}

	~UniqPtr() {
		delete[] *ptr_;
	}

private:
	T* ptr_ = nullptr;
}


int main() {
	UniqPtr ptr(new int(123));
	UniqPtr ptr(new int[5]);
}
таким образом мы сделали свой умный указатель

да, приходится писать по два раза функции и в теории можно было бы вынести общее в какой-то общий класс

но а вдруг нам для массивов надо было бы писать совсем другое
```


```cpp

template <typename T, typename... Args>
UnitPtr<T> MakeUniq(...) {
	
}
позволяет описывать шаблоны с переменным число параметров
вместо Args можно поставить сколько угодно параметров
это нам нужно, чтобы нормально передавать конструкторы для всех типов

template <typename T, typename... Args>
UnitPtr<T> MakeUniq(Args... args) {
	return UniqPtr<T>(new T(args...));
}

auto ptr = MakeUniq<std::vector<int>>(100);

std::cout << ptr->size();




auto ptr2 = MakeUniq<std::tuple<int, double, std::string>>(100, 0.9, "hello");

tuple примерно так и реализован, только через рекурсию от size() - 1
УПРАЖНЕНИЕ НАПИСАТЬ ТАКОЙ КЛАСС))
```


```cpp

если в единице трансляции используется шаблон, этот шаблон должен быть в этой единице трансляции

поэтому обычно шаблоны пишут в .h


typedef std::vector<int> vec1;
using vec2 = std::vector<int>;


но using можно с шаблонами юзать

template<typename T>
using vec2 = std::vector<T, std::allocator<T>> // к примеру


использовать

vec2<int> - очень удобно использовать как alias
```


```cpp
когда мы пишем auto применяется тот же самый механизм как и для шаблонных параметров
```

