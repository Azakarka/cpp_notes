Работаем немного с классами

# class

## *модификаторы доступа*
```cpp
class Vector {
	std::vector<double> values_; // члены
};
```
у классов все члены (переменные) и методы (функции) по дефолту private

*Есть три модификатора доступа:*
1) public - доступно всем
2) protrcted - только внутри этого класса и наследникам (о них потом)
3) private - только внутри этого класса


*Struct vs class*
struct - по дефолту public
class - по дефолту private

**Как из const, мы хотим, чтобы поля были private, чтобы их лишний раз никто не трогал**

```cpp
class Vector {
public:
	size_t GetSize() {
		return values_.size();
	}
private:
	std::vector<double> values_;
}

Vector vector;
cout << vector.GetSize() << endl;
```

**сначала описываются методы, причем публичные, потом уже поля(члены)**


## *this*
```cpp
class Vector {
public:
	size_t GetSize() {
		return this->values_.size();
	}
private:
	std::vector<double> values_;
}

Vector vector;
cout << vector.GetSize() << endl;

// зачем нужен? (пример)

class Vector {
public:
	void SetValues(const std::vector<double>& values_) {
		values_ = values_; // не произойдет
	}
	...
}
```

> [!INFO] одинаковые названия
> C++ может хранить переменные с одним именем, если они были объявлены в разных скоупах, берет он последний объявленный.

## *траблы с const*
```cpp
class Vector {
public:
	size_t GetSize() {
		return values_.size();
	}
private:
	std::vector<double> values_;
}


const Vector vector;
cout << vector.GetSize() << endl;
// будет ругаться, так как функция не const



	size_t GetSize() const {
		return values_.size();
	}
// эта штука говорит, что мы не изменяем никакие поля
```

```cpp
class Vector {
public:
	size_t GetSize() сonst {
		return values_.size();
	}

	double& At(size_t index) {
		return values_[index];
	}
private:
	std::vector<double> values_;
}

Vector vector;
vector.At(0) = 10;
cout << vector.At(0) << endl;
// выведет 10



void Print(const auto& vector) {
	cout << vector.At(0) << endl; // не получится так как vector const
}



// поэтому реализуем новую функцию

	double& At(size_t index) const{
		return values_[index];
	}
// но это не сработает, потому что ссылка все равно не константная, поэтому
	const double& At(size_t index) const{
		return values_[index];
	}
// это уже будет работать
// если у нас два метода с одинаковым именем, компилятор выбирает по константности
```

## *mutable*
```cpp
class Vector {
public:
	
	const double& At(size_t index) const{
		++calls_;
		return values_[index];
	}
private:
	std::vector<double> values_;
	size_t calls_ = 0;
}
// мы хотим, чтобы можно было изменять некоторые штуки и вести счетчик, поэтому делаем
	mutable size_t calls_ = 0;
// компилятор не будет ругаться, однако если мы юзаем mutable, скорее всего у нас плохой код, можно придумать что-нибудь другое
```



## *опять this*
Что есть this?
```cpp
Указатель-то очев const, но

1) в неконстантных методах так
//Vector* const this
так как нам можно и нужно менять штуки внутри класса


2) в константных так
// const Vector* const this
так как нам нельзя ничего менять
mutable кст меняется, не смотря на то, что у нас const 
```



## *friend*
```cpp

void PrintCalls(const Vector& vector) {
	std::cout << vector.calls_ << endl;
	// вообще это плохой код, если нам нужно работать с полями, но иногда по-другому никак
	// чтоб это сработало нужно написать

class Vector {
	...
	friend void PrintCalls(const Vector& vector);
}

// класс понимает, что он друг и дает доступ ко всему, что в нем есть (в том числе и к приватным)
}
```



## *static*
```cpp
class Vector{
	...
	static double Norm(const std::array<double, 3>& values) {
	}
	...
}
// static функция - функция, которая как бы не относится к классу, а просто удобно в нем лежит


class Vector{
	...

	double CalcNorm2() const {
		double sum = 0;
		for (double v : values_) {
			sum += v*v;
		}
		return sum;
	}

	static double Norm(const std::array<double, 3>& values) {
		Vector vector;
		vector.At(0) = 1;
		vector.At(1) = 2;
		vector.At(2) = 3;
		return vector.CalcNorm2();
	}
	...
}
// static функции можно позвать вне класса

cout << Vector::Norm2(values) << std::endl;

// Norm2 - по сути имя, а Vector фамилия, в остальном функция никак не связана с классом, просто удобно лежит
// так как по сути нет класса, то и нет полей, поэтому с ними работать мы не можем
cout << Vector::Norm2(values).GetSomething() // писать конечно нельзя

// однако удобно, что такой функции доступны приватные поля
static double Norm(const std::array<double, 3>& values) {
		Vector vector;
		vector.At(0) = 1;
		vector.At(1) = 2;
		vector.At(2) = 3;
		++vector.calls_;
		return vector.CalcNorm2();
	}
// получается, что статик тоже самое, что и friend, просто пишется и понимается поприятнее
```



## *жизненный цикл объекта*
```cpp

class Vector{
	...
}

Vector vector; // вектор создался
cout << vector.GetSize() << endl; 

return 0; // в конце скоупа удаляется
```

## *construcrtor*
```cpp
class Vector {
	Vector() {
		std::cout << "Constructor" << std::endl;
	}
	~Vector() {
		std::cout << "Destructor" << std::endl;
	}
}
// зачем это надо???

class Vector {
	Vector() { // конструктор без полей - дефолтный конструктор
		std::cout << "Constructor" << std::endl;
		values_.resize(3);
	}
	~Vector() {
		std::cout << "Destructor" << std::endl;
	}
}



	Vector() : values_(3), calls_(0) { // initializer list
		std::cout << "Constructor" << std::endl;
	}
	// мы от каждого типа как бы вызываем его собственный конструктор


	Vector(size_t& calls) : values_(3), calls_(calls) {
		std::cout << "Constructor" << std::endl;
	}
	// к примеру с ссылками можно делать только так, потому что ссылка не может быть неинициализирована
	...
	calls_ = calls // соответсвенно так не можем



	Vector(size_t size) : size_(size), values_(size_) {
		std::cout << "Constructor" << std::endl;
	}
	// так может не сработать, так как инициализирование происходит по очереди того, как они объявлены
	// то есть при
private:
	vector<int> values_;
	size_t size;
	// не сработает, вернее values_ будет рандомного размера!!!!!!!
```


## *explicit*
```cpp

class Vector {

	Vector(size_t size) : values_(size) {
	
	}
	...
}


void Print2(Vector vector) {
	...
}

Print2(100); 
// когда мы создаем конструктор с одним полем (кроме дефолтных аргументов), может быть такой прикол, что к нему может произойти неявное преобразование


// обычно мы так делать не хотим, поэтому
	explicit Vector(size_t size) : values_(size) {
		
	}
// так уже не получится неявно приводить
```

## *делигирующий конструктор*
```cpp

	explicit Vector(size_t size) : values_(size) {
		
	}

	Vector() : Vector(0) {
		
	}
	// Правила делегирования:
	// 1) делегирование может быть многоуровевым, но не рекурсионным
	// 2) нельзя смешивать список инициализации и делигирующий конструктор
```
