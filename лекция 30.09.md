


```cpp
#include<string>
```
команды решется это комманды при препроцессоре. их обрабатывает программа до компилятора, он обрабатывает все эти макросы, а потом дает их компилятору. 


Инклюд находит такой файл и просто вместо этой строчки вставляет код с этого файла. 


как получается что выходит в итоге, можно c++ -E lecture.cpp и он туда выведет код который и дается компилятору. 



пишем свой хедер

```cpp
	in print.h

	void Print(const string& str) {
		cout << ;
	}

	in main.cpp

	#include "print.h"
	все будет работать также, как будто эта функции стоит в cpp
```

если треугольные скобки, он ищет их в стандартных путях, в стандартной библиотеке

если в других кавычках он ищет в текущей директории, а потом идет уже искать в стандартную библиотеку

треугольные скобки или кавычки повышают читаемость кода

что если делать рекурсию штук

```cpp
	in print2.h
	#include "print.h"

	in print.h
	#include "print.h"
```
не будет работать, так как у нас возникнет переопределение функции print

```cpp
#pragma once 

он говорит что если мы когда-то инклюднули уже такой файл, то второй раз его инклюдить не надо
```


есть другой способ
```cpp
#ifndef PRINT_H
#define PRINT_H

your code goes here...

#endif

```


что такое дефайн? это макрос препроцессора, который как бы создает переменную препроцессора

в коде препроцессора поставится 1
```cpp

#define ONE 1


cout << ONE << endl;
```

ifndef это if not defined, то есть если не опредена, мы ее определяем. соотвественно во второй раз он его не заинклюдит.

Прагама ванс не стандартная комманда, но его почти все поддерживают, так что можно юзать. 


.hpp это просто .h для плюсов, разницы нет

заинклюидить можно все что угодно, так как препроцессор работает чисто с текстом, ему все равно, но вопрос скомпилится ли это остается открытым.

``` cpp
#define ONE

#ifdef ONE
HELLO
#endif

абсолютный мем
```

дефайн это по факту просто подстановка текст, грубо говоря replace в коде.


когда нужно
1) include
2) сложный кросс-платформенный код, и на разных платформах могут быть разные функции, поэтому if мы на винде одно else на линуксе делает другое

```cpp

есть комманда __FILE__ и __LINE__ пусть и строчка

```

```cpp

void print(string str) {
	cout << str;
}
```

может не работать, это зависит от такого что мы инклюдили до этого

поэтому в хедеры корректно писать все что нам может понадобиться

```cpp
	in print.h

	void print(string str);


	int print.cpp
	надо его во-первых в cmake добавить, а во-вторых

	
```

спп код называется единициой трансляции и они компилятся независимо. Что такое файлы .o ? они такие же как исполняемые файлы, только для нескольких спп файлов 


препроцеесор комплятор линкер, все скомпилившиеся спп файлы лежат в одном бинарнике


в чем прикол разделенных файлов? если мы меняем одну единицу трансляции, то нам надо перекомпилить только ее

компиляторы умные и знают что мы меняли, а что нет

если код был в принт х нам надо было бы перекомпилить все единицы трансляции, поэтому раздельная компиляция очень вкусная.



получается в заголовочном файле храним необходимый минимум

обычно в хедерах сначали идут стандртные библиотеке, а в плюсах наоборот - чтоб подтягивать все нужные библиотеки.