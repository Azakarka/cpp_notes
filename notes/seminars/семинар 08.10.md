
## **Разбор ошибок домашки**

Если задать  < и == , зададуться <=  >=  >  <  ==  то есть все остальные


# **Наследование**

Сначала выделяются все поля базового класса, потом уже потомков

такая реализация по памяти сделана для полиморфизма, чтобы указатель на базовую структуру ничего не знал о классе наследника

из студента каст в человека происходит неявно

можно из человека кастоваться к студенту, для этого используется dynamic_cast. То есть мы уверены что делаем то, что надо.
```cpp
void f(Person * ptr);
void f(Stduent * ptr);

Student s;
Person* p;
p = &s;
f(p); // вызовет от персон
f(s); // вызовет то что стоит выше в коде
```

public vs private
приватное наследование не будет неявно кастовать, и от туда уже теряется весь функционал наследования с его виртуальными функциями и прочим

адресный полиморфизм - неявная кастовка к базовому классу

![](Workspace/ucheba/cpp_notes/пикчи/sem0810/img1.png)
вот такая штука не скомпилится, потому что у нас пересечение имен, но это не виртуальные функции с одной сигнатурой


void foo() = 0; // даже без виртуал делает абстрактным, но лучше писать с виртуал для понятности

void foo() override {} // тоже можно без виртуал, но для читаемости лучше написать

void foo() final {}; // ниже в наследниках уже переопределять не будут, тоже для виртуальных




![](Workspace/ucheba/cpp_notes/пикчи/sem0810/img2.png)

B* b = new C();
b->bar;
какая функция вызовется?

правильно C::bar() потому что у нас метод бар виртуальный, а при неявном кастовании указатель на виртуальную таблицу останется на классе С.



асимптотика поиска по таблице константная



зачем нужен виртуальный деструктор?
```cpp
class B {
	
}

class C : public B {
	
}

B *b = new C();
delete b;
вызовет деструктор от B, так как деструктор это просто обычный метод и без virtual он запустится именно от класса B а не класса C

понятно что если не запускать деструктор от класса C ничего не очистится, только от класса B
```


![](Workspace/ucheba/cpp_notes/пикчи/sem0810/img3.png)
Самостоятельная работа: определить что тут выводиться

Ответ: 
>! one three 14 3 four two (я пытался скрыть)

Общий алгоритм: 
ptr->f() 
программа начинает искать f() в виртуальных функциях, она ее не находит, поэтому идет искать функцию A::f(), именно A, а не B, так как у нас указатель типа A.

b.f() так как b не ссылка или указатель, поэтому поиск в таблице виртуальных значений просто не осуществляется.

```cpp
class F : public Status, public Time {}
множественное наследование
```
![](Workspace/ucheba/cpp_notes/пикчи/sem0810/img4.png)
вот пример множественного наследования



# механизм исключений
он очень дорогой, поэтому им не надо спамить

try catch throw
![](Workspace/ucheba/cpp_notes/пикчи/sem0810/img5.png)
try block - блок, в котором мы ожидаем исключение
catch - ловит исключение если кинулось
throw - бросить само исключение

вывод на верхнюю задачу
Inside try Exception Caught After catch

если бы мы не смогли поймать ошибку, к примеру она была бы string, то catch кинулся бы на уровень выше, то есть аварийное заваршение программы
![](Workspace/ucheba/cpp_notes/пикчи/sem0810/img6.png)

![](Workspace/ucheba/cpp_notes/пикчи/sem0810/img7.png)


![](Workspace/ucheba/cpp_notes/пикчи/sem0810/img8.png)
тут выполнится catch (Parent b)




![](Workspace/ucheba/cpp_notes/пикчи/sem0810/img10.png)

catch (...) это как default в switch-case


![](Workspace/ucheba/cpp_notes/пикчи/sem0810/img11.png)
![](Workspace/ucheba/cpp_notes/пикчи/sem0810/img12.png)

исключение из деструктора выкинется на самый верх
```cpp
try {
	A a;
	throw logic_error("another");
}
если при уничтожении a что-то идет не так, мы по сути скрываем реальную ошибку, так что на самый верх
```

![](Workspace/ucheba/cpp_notes/пикчи/sem0810/img13.png)
noexcept говорит, что исключений из функции лететь не должны, поэтому если что-то полетит, то опять таки ошибка летит на самый верх, то есть аварийное завершение всей программы


![](Workspace/ucheba/cpp_notes/пикчи/sem0810/img14.png)
unique нельзя копировать
shared могут юзать несколько
weak = shared, но без фактической власти над памятью, решение проблемы DeadLock


![](Workspace/ucheba/cpp_notes/пикчи/sem0810/img15.png)
опять таки weak_ptr не увеличивает число указателей.
use_count выводит количество указателей, показывающих на эту память


![](Workspace/ucheba/cpp_notes/пикчи/sem0810/img16.png)деструкторы тут вызываться не будут, так как там цикл получится


# Шаблоны
сделать код для разных типов

```cpp
template <typename T> // или <class T>
void SortBubble(vector<T> v) {
}

вызывать можно как
SortBubble<int>();
или 
SortBubble(vector<int> vec);
```

по факту компилятор просто создаст несколько функций разного типа и их запускать

```cpp

если мы хотим для типа int сделать отдельную реализацию, пишем так
template<int>
void SortBubble(vector<int> v) {
	...
}
```