# Операторы


## **Конструктор копирования**
```cpp
class Vector {
	Vector() {
	}

private:
	vector<int> values_;	
}

и такой вот код
Vector vec1;
Vector vec2 = vec1;

такая штука как не сложно догадаться называется конструктором копирования
```


```cpp
Как такой конструктор написать?

Vector(const Vector& other) {
}

он принимает константную ссылку на объект того же класса, а потом копирует все поля

можно написать свое копирование
Vector(const Vector& other) {
	values_ = other.values_;
}
```

```cpp
Также контструктор копирования вызывается и при такой записи

Vector vec1;
Vector vec2(vec1);
```


## **Оператор присваивания**

```cpp
Vector vec1;
Vector vec2;
vec2 = vec1;

тут уже не вызывается конструктор копирования, потому что объект уже создан, то есть у него есть какие-то значения, ему их просто надо обновить
```

```cpp

auto operator=(const Vector& other) {
}

- синтаксис оператора присваивания


Подумаем, что же должно быть вместо auto?

в плюсах есть такой прекрасный синтаксис как
x_1 = x_2 = x_3

который выполняется как
x_1 = (x_2 = x_3)

соотвественно когда мы присваиваем какой-то штучке, хочется чтобы потом кому-то можно было присвоить уже его. А значит возвращаем ссылку на объект

Vector& operator=(const Vector& other) {
	values_ = other.values_;
	return *this;
}
```

> [!NOTE] Замечание
> в auto operator=(const Vector& other);
> вместо auto может стоять все, что угодно, однако мы хотим поддерживать семантику языка, поэтому возвращаем ссылку



```cpp
Возникает закономерный вопрос, если мы на вход берем константную ссылку, то почему отдаем обычную?

Очень просто, иногда хочется сделать вот так

(vec1 = vec2).do_sth();

соотвественно если метод не константный, то и вызвыть у нас ничего не получится.

+ просто так пишут и так удобнее, лучше не возвращать конст ссылку (у меня clion даже ругается на такое)
```

Что еще хорошо было бы дописать?

```cpp
Иногда может случиться такое, что
vec2 = vec2;

как правило мы не хотим, чтобы эта штука что-то меняла, поэтому пишем

Vector& operator=(const Vector& other) {
	if (this == &other) {
		return *this;
	}
}

```


## **default & delete**

Что ж, мы написали свои операторы присваивания и конструкторы копирования, но почему когда мы это не делаем, все все равно работает?

А потому что компилятор умный и сам за нас пишет эти дефолтные штуки

*Так когда надо писать свой, а когда надо оставлять работу компилятору?*

```cpp
Очень просто. Если у вас нет чего-то сложного в классе, к примеру у вас просто вектора, инты, строки, мапы и тд - то есть то, что легко и понятно копируется, то лучше оставить это все компилятору
class Easy {
	int easily = 0;
	vector<double> trivial;
	map<int, string> apparent;
	...
}
- компилятор сам все легко скопирует.

!!!НО!!! если у вас собственно ручное выделение памяти (которое напомню нужно чистить самому) или какие-то указатели или еще что-то - в общем все, что может скопироваться плохо надо писать самому.
Наглядный пример:
class Vector {

	Vector() {
		arr = new int[50];
	}

private:
	int* arr;
}

если юзать дефолтное копирование, то у нас тупо скопируется ссылка и у двух разных объектов будет один и тот же массив!!! Понятно что это плохо, и это точно не подразумевалось.
```

```cpp
Чтобы компилятор лишний раз не баловался, можно запретить создавать ему дефолтные штуки, к примеру

Vector(const Vector& other) = delete; 
запретит ему создавать дефолтный конструктор копирования.

то же самое можно и с = сделать (да вроде с чем угодно)
Vector& operator=(const Vector& other) = delete;
```

*Получается лучше всегда на всякий случай писать свои штучки?*

Нет, если в классе не подразумевается что-то такое, что неправильно копируется, лучше оставлять все компилятору. Почему? 
1) Когда добавите новую переменную, можете забыть ее проинициализировать в конструкторе и пиши-пропало, а вот машина не забудет
2) Тупо меньше кода. Зачем много кода, когда можно мало кода?

## **Правило 0 и 3(5)**

3(5): Если мы написать деструктор или оператор присваивания или конструктор копирования - нам нужно написать и два других. С c++11 на самом деле это правило 5, так как там добавляется штучка move. 
Правило используется если у нас есть какое-то владение ресурсом или нетривиальное копирование.

Если у нас все с копированием хорошо, у нас какие-то понятные объекты, используем правило нуля, то есть оставляем все дефолтным.


# **Операторы**

```cpp
когда мы делаем какое-нибудь
Vector vec1;
Vector vec2;
vec2 = vec1

на самом деле выполняется
vec2.operator=(vec1) 
что еще раз показывает, что операторы это просто функции
vec2 = vec1 - просто является синтаксическим сахаром
```

Несколько моментов про перегрузку:
1) нельзя ввести новые операторы (к примеру # @)
2) нельзя перегружать "::", ".", "?:"(тернарный), а -> можно
3) приоритет сохраняется, то есть * будет вызвана раньше + и тд


## **Операторы сравнения**

Начнем с базы - с " == "
```cpp

bool operator==(const Vector& other) const {
	return vec.size() == other.size();
}
возвращаем естественно булинчик, в полях у нас другой такой же объект, а еще сигнутура функции имеет const.


Интересный факт, что с какого недавнего старндарта плюсов (17 или 20), если мы сделали ==, то компилятор за нас автоматически сделает != (если мы конечно сами его не написали). В обратную сторону не работает.
```

Что ж, но чтоб сравнивать что-то нам нужно ну уж очень много чего писать, это и "<" и ">" и " == " и '"<=" и еще пару штук. Неудобно, поэтому с 20 плюсов появился этот рыбокит.

## **spaceship (<=>)**

```cpp

auto operator<=>(const Vector& other) const {
}

вообще auto может быть weak_ordering, strong_ordering и partial_ordering, но это уже что-то сложное

Как он работает?
как и с strcmp, он выводит число меньше 0, если левый объект меньше, больше нуля если больше и 0 при равенстве.

cout << (vec1 <=> vec2 == 0); 
выведет равны ли строки

эту штуку можно делать дефолтом

auto operator<=>(const Vector& other) const = default;

ну или реализовать как-то

auto operator<=>(const Vector& other) const {
	return vec.size() - other.vec.size(); \\ ну такое по факту может сломаться так как size_t
}

```

```cpp
Так почему спейсшип удобен? На основе spaceship компилятор сделает дефолтные операторы для всех сравнений. 

auto operator<=>(const Vector& other) const = default;

vec1 <= vec2
эквивалетно
vec1 <=> vec2 <= 0

!!!НО!!! не ==
== дефолтно не создается, так как почти всегда == можно сделать оптимальнее чем обычное сравнение, поэтому язык не позволяет прогерам писать неэффективный код.
```

```cpp
Также как факт можно реализовать каждое сравнение ручками, комплятор не будет создавать дефолтный, если вы зададите свой сами.
bool operator<(const Vector& other) const { // при < будет вызываться этот
	return random();
}

auto operator<=>(const Vector& other) const = default;
```

## **релизуем ПРОСТОЕ сложение**

```cpp
Пусть мы хотим написать что-то такое

vec1 = vec2 + 100;

тогда просто напишем
Vector operator+(int mem) const{
	Vector new_vector = *this;
	...;
	return new_vector;
}
Мы не хотим менять исходный объект, поэтому const

мы делаем копирование, потому что если возвращать ссылку, объект уже умрет, так как он локальный, поэтому приходится копировать.

Вроде все легко, ну а что если

vec2 = 100 + vec1;
перепишем класс int (при условии что он примитив)?

НОУП, это дело для больших дяденек
```


## **операторы-функции**
можно сделать оператор-функцию вне класса

```cpp
... где-то вне класса ...
Vector operator+(int mem, const Vector&vec) {
	Vector new_vector = vec;
	...;
	return new_vector;
}

И да, без friend мы не будем иметь доступ к приватным материалам
но никто не мешает кинуть эту функцию в сам класс, навесив friend конечно же
```

## **инкремент**

```cpp

Vector& operator++() {
	...
	return *this;
}
как мы знаем префиксный ++ увеличивает значение на 1 и возвращает ссылку на новое значение, чем мы и занимаемся)
++vec1; - сработает

++++++++++vec1; - по секрету даже это сработает опять таки потому что мы возвращаем ссылку

Что насчет постфиксного? Тут надо написать костылик чисто для компилятора
Vector operator++(int) { // да просто написать int
	Vector old_vec = *this;
	...
	return old_vec;
}

понятно чтобы нам вернуть старый объект его нужно скопировать и уже отдать не по ссылке, ведь он локальный

```


# **пошел какой-то обман**

Какие-то фантастические фокусы

```cpp

Нетривиальный финт, мы хотим сделать чтобы наша штука неявно к чему-то приводилась

То есть в прошлой записи мы убирали, чтобы какая-то штука становилась нашей, а сейчас хотим колдовать над своей

ПРИМЕР:
if (vec1) { // хотим чтоб дават тру если вектор не пустой
}


для таких выкрутасов нам дали возможность написать

operator bool() {
	return !vec.empty();
}
заметим, что перед оператором ничего нет, потому что и так понятно что мы выведем, ведь это написано после
```

```cpp

теперь можно писать

bool b = vec1;

но обычно мы не хотим чтобы вектор неявно приводился к булу, так как где-то как-то случайно не то не там сделаем, передадим не бул, а вектор и тд и тп.

Поэтому сделаем explicit аче нам)
explicit operator bool() {
	return !vec.empty();
}

теперь bool b = vec1; не сработает

Вопрос нафиг надо? Ну, во-первых для булинчиков если исключение в виде
if (vec1) {
	// он продолжит компилиться
}

а во-вторых все еще можно делать так

bool b = static_cast<bool>(vec1);
так что жизнь не так уж и ужасна
```

## **Концовку слили**

да лан шучу, все еще вкусно

```cpp
хотим чтоб вот так вот пжпжпжпп

cout << vec1;

видим (замечаем), что не получится написать что-то типа
operator<<(){
	do sth
}
просто потому что слева у нас cout, а не наш чел

поэтому как и в примере с 100 + vec1 нам надо сделать отдельную функцию

std::ostream& operator<<(std::ostream& stream, const Vector& vec) const{
	stream << vec.vec_ << std::endl;
}

Опять таки возвращаем ссылку, так как хотим, чтобы такое работало 
cout << 228 << 1337 << vec << "abacaba" << ...;
то есть это по факту просто последовательное выполнение операторов, в этом плане << никак не отличается от других операторов.

Ну и понятно, делаем это вне класса, а если хотим чтобы юзались приватные поля дружимся через friend

```