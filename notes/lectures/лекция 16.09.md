# AUTO (хендай)
В плюсах есть ключевое слово auto

Он сам определяет тип переменной:
```cpp
auto i = 10;
```
Тип auto удобно юзать для типов с очень длинным названиями

Также код будет более адоптивный
```cpp
long GetNum() {
	return 10;
}

auto i = GetNum();
```

```cpp
int i = 0;
int& i_ref = i;

auto j = i_ref; // j - int
auto& j = i_ref; // j - int&
const auto& j = i; // константная ссылка
// не забываем что константная ссылка продлевает жизнь временным объектам до конца скоупа
```

```cpp
auto GetNumber() {
	int* i = nullptr;
	if (true) {
		return i;
	}
	return nullptr;
	// не скомпилится
	// нужен либо static_cast либо выводить не auto, а int*
	// потому что nullptr это отдельный тип данных
}
```

# Чета
```cpp
	int numbers[3]; // база задачи массивов
```
> [!NOTE]
> Изначально заполнен мусором
> 
> можно делать так:
> int numbers[3] = {1, 2, 3}
> 
> int numbers[3] = {1, 2}
> заполняет заданные, а хвост нулями
>  
> int numbers[3] = {}
> все нулями

```cpp
int numbers[3] = {1, 2, 3};
int* numbers_ptr = numbers;
// *(numbers_ptr + i) == numbers[i]
```

## Передача
```cpp

void Print(int numbers[3]) {
	cout << sizeof(numbers);
}
// массив передается как указатель, то есть вышенаписанное ==
void Print(int* numbers) {
	cout << sizeof(numbers);
}
```
> [!INFO]
> Для указателей работают квадратные скобочки!!!
> int * numbers;
> numbers[3]

> [!WARNING]
> Получается что массив по факту передается по ссылке, так что его надо аккуратно менять в функции

Двойные массивы
```cpp
int numbers[2][3] = {{}, {}};
int* numbers_ptr = numbers;
// не скомпилится

Как сделать нормально не тривиально, так что не балуемся
```

## Строки

```cpp
string str = "hello";
cout << "hello";
// разные штуки, в cout это char*

char* str = "hello";
```
char* в конец ставит \0 и идет читает с первого элемента пока не найдет этот элемент, поэтому если взять указатель дальше строки, он будет бежать далеко до первого \0
```cpp
char* str = "hell\0o";
// выведет hell
```

C-строки не очень-то и удобные 
```cpp
cout << "Hello " + " world";
// не компилится
if ("hi " < "hello") // сравнивает два указателя, а не строки

#include <cstring>
if (strcmp("Hello ", "world"))
// 0 - равно, < 0 - первая больше, иначе вторая
```

```cpp
#using namespace std::literals;
if ("Hello "s == " world"s) // уже нормальные c++-шные строки
```

> [!NOTE]
> Можно сделать свою стандартную библиотеку, то есть написать свой литерал к примеру


## Русские строки (нормальные)

```cpp
std::string str = "hello";

str.c_str(); // дает char* 
str.data(); // делает по факту тоже самое, но еще и сделан под вектор для шаблонов 
str.find("ll"); // индекс первого вхождения


string str = to_string(10);
stoi(), stol(), stoll() - возвращает из строки int, long, long long соответственно
```

> [!Warning]
> если сравнить с-строки "Дора" и "Мейби бейби" без \0 может сгореть пк
>

## Векторинки

```cpp
std::vector<int> numbers = {1, 2, 3};

// имеет
int* data;
size_t size;
size_t capaity;

// если size + 1 <= capacity - все быстро нормально работает, просто в конец пихается

int* data = numbers.data();
for (int i = 1; i < 10000; i++) {
	numbers.push_back(i);
	if (data != number.data()) {
		cout << "Reallocation: " << i << std::endl;
		data = numbers.data();
	}
}
// можно увидеть что он в два раза увеличивает capacity
// для того чтобы не реаллоцировать, можно написать
numbers.reserve(10000);
// он возьмет не ближайшую степень двойки, а именно столько сколько указал
// если push_back-нуть на один больше будет 20000, то есть он просто удваивает
```

> [!WARNING]
> если смотреть дальше нужного то есть numbers[numbers.size()], то будет либо undefined behaviour либо SIGSEV

> [!NOTE]
> есть numbers.at(i) который с ификом проверяет не вышли ли мы за вектор


## Итераторы

```cpp

auto it = numbers.begin();
// итератор это как бы указатель
auto it_end = numbers.end(); // end невключительно

// операции
*it //разыменовывание оператора
++it или it++ // след итератор 
--it // предыдущий (у некоторых нет, к примеру у односвязного списка)

++it // возвращает новое значение
it++ // возвращает старое значение и он менее эффективнее из-за всяких копирований, поэтому лучше юзать префиксный ++

for (auto it = numbers.begin(); it != numbers.end(); ++it) {
	int n = *it;
	cout << n << std::endl;
}
// тоже самое что и
for (int n : numbers) {
	cout << n << endl;
}

// видно что элементик-то копируется, поэтому можно поставить ссылочку, а еще лучше константную
for (const string& s : strings) {
	cout << s << std::endl;
}

```

