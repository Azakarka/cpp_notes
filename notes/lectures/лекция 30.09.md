# Препроцессор

Немного о том что такое препроцессор и с чем его едят.


## **include**
```cpp
#include <string>
```
команды решетка это комманды при препроцессоре. их обрабатывает программа до компилятора, он обрабатывает все эти макросы, а потом дает их компилятору. 

*Что конкретно он делает?*
```cpp

для наглядности пусть string выглядит так:
string.h {
	// some code
	// some functions
	// etc.
}
а наш cpp файл так:
main.cpp{
	#include <string>

	int main() {
		std::string s = "ДОРА БУДЬ МОИМ УНИТАЗОМ";
		std::cout << s << std::endl;
	}
}

```
так вот, что же делает препроцессор? Он берет смотрит на этот инклюд, и начинает искать файл с таким названием. Если он его находит, он вставляет содержимое этого файла вместо строки `#include sth`. То бишь наш код получится таким:
```cpp
main.txt (я так и не понял какое расширение имеет файл, но думаю пофиг) {
	// some code
	// some functions
	// etc. 
	просто вставилось вместо той строчки инклюд
	
	int main() {
		std::string s = "ДОРА БУДЬ МОИМ УНИТАЗОМ";
		std::cout << s << std::endl;
	}
}
```

Для супер любознательных (видимо меня) лектор говорил, что комманда `` c++ -E main.cpp`` выведет в консоль содержимое этого самого обработанного препроцессором файла main.txt.

Я не разобрался как это выводить в отдельный файл, так что кто знает пишите :)


## **пишем свой хедер**

```cpp
print.h {

	void Print(const string& str) {
		cout << ;
	}
}

main.cpp {

	#include "print.h"
	все будет работать также, как будто эта функции стоит в cpp
}
```

>[!NOTE]
> треугольные скобки обозначают, что файлик находится в стандратной библиотеке
> 
> кавычки соотвественно в локальной, но если тут не найдется, он пойдет искать в стандартной

пжешка пишите те скобки, которые именно подразумеваются, это увеличит читаемость кода и прочее десятое


## **бахнем рекурсию?**

не выйдет
```cpp
print2.h {
	#include "print.h"
}
print.h{
	#include "print2.h"
}
```
Не понятно насколько долго это будет копироваться вставляться и прочее, но умное препроцессоры выдадут ошибку.
Даже если каким-то образом это вставится 100 тысяч раз (и еще 2 миллиона на подходе), код просто-напросто не скомпилится, так как функции будут определены несколько раз.

## **pragma once**

сильная и независимая. что она делает?
```cpp
#pragma once 

такая штука в начале кода хедера говорит, что мы его уже инклюдили и можем повторить делать не надо
```

Альтернативная концовка
```cpp
#ifndef PRINT_H если такой переменной нет
#define PRINT_H создадим такую переменную

your code goes here...

#endif выйдем из ифика

это все на уровне препроцессора, так как опять таки комманды "#" относятся к нему

```
препроцессор зайдет в хедер копипастнет его, и инитнет переменную, когда ему понадобится вставить код второй раз он вставит пустоту, так как не зайдет уже в if.

Зачем так писать? Ну, pragma once вообще может не существовать на чайнике с функцией жопа, поэтому там такой код может не сработать, а вот старый добрый ifndef + define + endif работает везде.

*Кстати*
В хедерах стандартной библиотеки стоит как раз таки ifndef + define + endif. Не утверждаю, что во всех, я глянул только парочку. 
Чисто такой прикол, что в clion если зажать ctrl или alt (точно не помню) и нажать на что-то тебя кинет в место где это написано, соотвественно если нажать таким образом на string в ``#include <string>`` можно почитать там увлекательный код.


## **define**

дефайн это по факту просто подстановка текст, грубо говоря replace в коде
``` cpp

main.cpp{
	#define ONE 1
	...
	cout << ONE;
}

main.txt{
	// nothing
	...
	cout << 1;
}
он просто на этапе обработки подставит вместо ONE 1 и дело сделано.
```

а еще вот так (просто мем)
```cpp
main.cpp{
	...
	#define ONE // инитим ONE

	#ifdef ONE // если ONE есть, то
	HELLO
	#endif // кончился ифик
	...
}

main.txt {
	...
	HELLO
	...
}
и да это просто не скомпилится

```

Использовать define плохая практика, так как есть обычные перемены, вам зачем он вообще???? НО!:
1) для include
2) сложный кросс-платформенный код
К примеру пишем мы brawl stars.exe на яблоко и андройд, а у них разные функции для вывода картинки на экран, ну тогда мы просто ифаем, что если мы на яблоке, то выводим так, а если на андройде, то по-другому.


## **всякие встроенные макросы**
```cpp
__LINE__ - говорит на какой строчке

__FILE__ - название файла

__DATE__ - This contains a string of the form month/day/year that is the date of the translation of the source file into object code.

__TIME__ - This contains a string of the form hour:minute:second that is the time at which the program was compiled.

да я украл, но мне можно
https://www.tutorialspoint.com/cplusplus/cpp_preprocessor.htm
```

## еще немного об include
```cpp

Вот эта фигня в функции принт может не скомпилится потому, что string мы инклюднули в .cpp, а не в .h

void print(string str) {
	cout << str;
}
```
Золотое правило: в .h пиши все что нужно, но по минимуму или к тебе ночью придет Бьёрн Страуструп и заберет подписку на clion. Подробнее об этом в следующей части подпишись на канал чтобы на забыть! Лан ща расскажу.


## **Единица трансляции**

Каждый cpp-шный файл это одна единица трансляции. Что это и для чего нужно?

Каждая единица трансляции компилится независимо. Когда у вас один cpp файл в целом на это пофиг, поредачили какой-либо файл и заново все перекомпилили.

А теперь представим огромную компанию где 1337 cpp файлов, миллиарды строчек кода и всего прочего, а вы маленький неприметный HELLO_WORLD, который просто хочет вывести строчку. Если каждый раз компилить всю эту электронную биомассу, получится адское время ожадания. 

Поэтому придумали компилить каждый cpp файл независимо, а потом их объединять с помощью LINKER. Соотвественно в этой жизни cpp Микки Маус, а .h файлы просто его подручные, грубо говоря весь код можно написать в одном файле, что и делает собственно препроцессор.

В итоге у нас 4 фазы:
1) для каждого cpp файла пихнуть все, что юзается в один большой файл
2) для каждой биомассы скопмилить это
3) объединить между собой скомпиленных челов
4) выдать запускаемый файл

В общем-то говоря, если мы меняем какой-то .h файл, нам очевидно надо перекомпилить всех челов, которые на него ссылаются. Если мы меняем .cpp файл, нам только его надо менять. 

Поэтому писать в .h нужно минимум, к примеру:
```cpp
... - все что нам надо инклюднуть

class Mem; - всякие структурки, которые мы потом будем юзать

class Memes {
	void FunnyMemes(vector Memes); - в самих структурах функции, но опять таки без тела
	int memes_counter_; - поля классов и тд
}

то есть в .h надо писать все, но минимально, только дать понять, что у нас все это как бы есть или будет, но ничего конкретно не реализовывать, чтобы потом спокойно переписать всего лишь один cpp файл и не рекомпилить все 23423423423423423432 других cpp файлов.

```

обычно в хедерах сначала пишут стандартные библиотеки, а в плюсах наоборот, чтобы все нужные библиотеки подсасывать у хедеров.