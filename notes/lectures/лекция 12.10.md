
# *Exceptions*

в простонародье исключения

## **базовая основа**
Пусть вы хотите написать функцию деления
```cpp

Div(a, b)

double Div(double a, double b) {
	return a / b;
}
```


Но понятно, что есть особый случай, когда  b = 0 и мы хотим его обработать

```cpp
	
double Div(double a, double b) {
	if (abs(b) < 0.0001) {
		return Nan;
	}
}
// можно к примеру выделить специальное число под это дело
```

```cpp

// или более умно выдавать некоторый булинчик на успешность выполнения
double Div(double a, double b, bool& success) {
	if (abs(b) < 0.0001) {
		success = false;
		return 0;
	}
	success = true;
	return a / b;
}

int main() {
	bool success = false;
	double result = Div(1, 2, success);
	if (success) {
		// do sth
	}
}


// но видим, что кода очень уж много и какой-то он мерзкий
```


поэтому и придумали исключения
```cpp
// можно кинуть все что угодно
double Div(double a, double b) {
	if (abs(b) < 0.0001) {
		throw 1; // тут к примеру просто кинули int, аче нам)
	}
	return a / b;
}

// но лучше кидать стандартные ошибки, об этом попозже
throw std::exception();
```

Что вообще происходит когда мы кидаем какую-то ошибку?

если ошибка не ловится, происходит выход из функции, одновременно удаляя все локальные переменные, конечно.

затем мы попадаем в какую-то другую функцию, и если ошибка опять не ловится, опять выходим и тд, пока ее не поймаем.

если мы так и не поймали ошибку, наша программа просто аварийно завершится, то есть
```cpp 
void foo() {  
    throw 1;  
}  
  
int main() {  
    foo();  
    std::cout << "I've passed through" << std::endl;
}
```
а вот и аварийное завершение
![](Workspace/ucheba/cpp_notes/пикчи/uncaught_exception.png)



## **собственно ловить-то как?**

```cpp
// вернем старую добрую функцию, пока еще кидаем фигню
double Div(double a, double b) {
	if (abs(b) < 0.0001) {
		throw 1;
	}
	return a / b;
}

// а вот и блок try-catch
// ошибка, полученная из блока try будет пытаться пойматься в блоках catch
try{
	std::cout << Div(5, 0);
} catch(...) { // вот такая штука ловит вообще все на свете ошибки
	std::cout << "Error";
}
```

Теперь немного про то, что мы вообще должны выбрасывать.

std::exception - это в общем-то говоря не какой-то отдельный прикол языка

это просто отдельный класс в стандартной библиотеке, созданный для удобства вывода ошибок, то есть чтобы все программисты выводили не int, long, double и тд, а какой-то специальный класс для этого.

в общем-то как и любой класс, можно написать свой и выбрасывать его

но классы-ошибки принято наследовать от std::exception или от его наследователей
[вот к примеру их виды](https://en.cppreference.com/w/cpp/error/exception)

с этими знаниями продолжаем
```cpp

// так как e это просто объект класса, то ловим его через const &
catch(const std::exception& e) {
	std::cout << "Got std::exception";
}
// потому что обычно изменять или копировать его не надо

// что более важно, ссылка нужна для полиморфизма (неявный каст к предку)

double Div(double a, double b) {
	if (abs(b) < 0.0001) {
		throw std::out_of_range("error"); // в std::exception можно передать текст ошибки
	}
	return a / b;
}

int main() {
	try{
		Div(1, 0);
	} catch(const std::exception& e) {
		// из-за полиморфизма вызовется вот это
		...
	} catch (const std::out_of_range &e){
		...
	} 
}

```

```cpp
// если мы хотим перебросить ошибку дальше(то есть уровень выше), пишем
catch(/* sth */) {
	...
	throw;
}
```



## Исключения в (де)/(кон)структоре*
```cpp
// исключение в конструкторе


// пусть у нас есть какой-то класс, хранящий динамическую память
struct Foo() {
	Foo() {
		ptr = new int(10);
		throw std::exception; // у нас исключение в конструкторе
	}
	~Foo() {
		delete ptr;
	}
	private:
		int* ptr = nullptr;
};
// что может быть не так?

// на самом деле логично, что если мы вылетили из конструктора, то значит мы не создали объект

// а значит и удаляться он не будет, аче прикольно же)

// получается, что наш указатель не очистится, а тут и старый добрый MemoryLeak
```

есть еще страшнее
```cpp

// ладно с одним указателем, не создался и пофиг

// а представим, что у нас их два, первый создался а второму памяти не хватило
struct Foo() {
	Foo() {
		ptr1 = new int(10); // отработал
		ptr2 = new int(10); // кинул bad::alloc
		// и вот совсем нетривиально, что в таких случаях делать
	}
	private:
	int* ptr1 = nullptr;
	int* ptr2 = nullptr;
};
// это к слову еще одна агитация за умные указатели, которые воспитанные и за собой убирать умеют
```


а деструктор что?

а вот представьте, у вас вылезла ошибка, вы начали удалять переменные, и бац внутри деструктора вылезла еще одна ошибка. Понятно, что такое дело быть не должно, так что при ошибке в деструкторе программа сразу ложится
```cpp
class Foo {  
public:  
    int n;
    Foo(int n) : n(n) {  
        throw 1;  
    };   
    ~Foo(){}  
};  
  
int main() {  
    try {  
        Foo f(3);  
    } catch(int) {  
        std::cout << "exception!" << std::endl;  
    }  
}
// вот такой код выводит "exception"


// а такой падает сразу
class Foo {  
public:  
    int n;  
    Foo(int n) : n(n) {};  
    ~Foo(){  
        throw 1;  
    }  
};  
  
int main() {  
    try {  
        Foo f(3);  
    } catch(int) {  
        std::cout << "exception!" << std::endl;  
    }  
}
```



## noexcept и прочее
```cpp
class Foo() {
void Do() noexcept // или throw() {

}
}
// noexcept говорит что такой метод не может выбрасывать никакие исключения

// проблема в том что это обрабатывается на этапе работы, поэтому компилятор вас никак не остановит

// если эта функция выкинет исключение, это приведет к аварийному завершению программу

// так как даже на этапе компиляции это не обрабатывается, это чисто маркер для разработчиков

//выведет "yeah"
void foo(){ 
    throw 1;  
}  
  
int main() {  
    try {  
        foo();  
    } catch(...) {  
        std::cout << "yeah";  
    }  
}

// У ПА ПА ПА ПА ПА ПАМ ПА ПАРАМ ПАМ ПАМ ДЕТ, опять таки несловленная ошибка
void foo() noexcept {  
    throw 1;  
}  
  
int main() {  
    try {  
        foo();  
    } catch(...) {  
        std::cout << "yeah";  
    }  
}
```
саморазвитие залог крутого игрока в дока2, так что:
[noexcept](https://en.cppreference.com/w/cpp/language/noexcept_spec)
[throw](https://en.cppreference.com/w/cpp/language/except_spec)





# *СТАТИЧЕСКИЙ ПОЛИМОРФИЗМ*
шаблончики мои любимые

```cpp

// введем нашу новую блестящую функцию
int Sub(int a, int b) {
	return a - b;
}

int main() {
	std::cout << Sub(10, 5) << std::endl;
}

// хотим такие же для даблов
double Sub(double a, double b) {
	return a - b;
}

std::cout << Sub(3.5, 1.25) << std::endl;


// если пытаемся вызвать один от инта другой от дабла, то вызов не понятный, так как двузначно можно неявно кастануть к обеим функциям

// можно написать static_cast, чтобы этого избежать
```

> overload resolution - процесс разрешение вопроса какую фунцию нужно выбрать
> можно почитать на cppreference
> [вот тут](https://en.cppreference.com/w/cpp/language/overload_resolution)

писать для каждого типа данных минус не очень весело, так что

## **пишем шаблоны...**
```cpp
template<typename T>
T Sub(T a, T b) {
	return a - b;
}

// этот T можно использовать как какой-то тип

// когда мы вызываем нашу функцию Sub() от двух интов, он проверят если это два одинаковых типа, то идем дальше

// если это инт, то компилятор за нас генерит Sub() от интов, если бы мы передали double он бы генерил функцию от double

// на каждый запускаемый тип компилятор сам сгенерит функцию, причем на каждой вызов уже сущесвтующая функция не создается заново

// соотвественно если мы ни разу не вызовем функцию, компилятор просто не будет ее создавать, в бинарном коде даже такого нет

// Подводные? Если не делать тесты на свой шаблон, может выйти лажа, так как компилятор не проверяет код внутри шаблона, если шаблон для каких-то типов не создается. 

// если написать что-то типа такого
Sub(10.0, 5);
// он не сможет понять что делать, так как T может быть как double так и int


Sub<double>(10.0, 5);
// мы сами задали, что T - double и он уже нормально отрабатывает
```


```cpp
// пусть мы хотим кинуть указатели 

int arr[10] = {0};
std::cout << Sub(&arr[0], &arr[1]) << std::endl;

// Sub выдаст ошибку, потому что разность указателей дает не тот же тип что и они сами, а именно difference_type, то есть другой зависимый тип

// поэтому можно написать шаблон от двух типов
template<typename T, typename R>
R Sub(T a, T b) {
	return a - b;
}

// теперь уже надо явно указать что нам нужно вывести
Sub<int*, std::ptrdiff_t>(&arr[0], &arr[1]);


// не очень приятно
// попробуем поменять местами
template<typename R, typename T>
R Sub(T a, T b) {
	return a - b;
}
// в шаблонах можно опускать типы, если компилятор может понять какой тип нам нужен

// или можно сделать так

template<typename R, typename T = int>


// опускать шаблонные параметры можно только на суффиксе, поэтому можно написать
Sub<std::ptrdiff_t>(&arr[0], &arr[1]);



// тут можно вывести auto, если очень хочется упростить код, не надо забывать что все ретурны должны вывести один и тот же тип, чтобы auto сработал
template <typename T>
auto Sub(T a, T b) 
	R result; // = a - b
	result = a - b;
	return result;
}
```


### *decltype*
```cpp


// decltype на этапе компиляции опеределяет тип выражения, это выражение выполнятся НЕ будет
// то есть можно написать даже лажу, которая выбросит исключение, к примеру выход за границы
decltype(a - b) result; // result с типом разницы


// для большей уверенности что все нормально
// declval - возвращает ссылку на фиктивный объект, потом вызвать оператор или еще чего
decltype(std::declval<T>() - std::declval<T>());

// поэтому можно бахнуть
template<typename T>
decltype(std::declval<T>() - std::declval<T>()) Sub(T a, T b) {
	return a - b;
}
```

> вместо *typename* можно писать *class*, это просто названия

```cpp
// можно еще передавать какие-то переменные в шаблон
tempale<int N, typename T>
auto Sub(T a, T b) {
	return a - b + N;
}

std::cout << Sub<100>(10, 2); // выведет 108

// к примеру это релизовано для std::array, чтобы с точки зрения языка C++ массивы разных размеров были разными классами.
std::array<int, 100> a;
```

> есть шаблонные глобальные переменные 



### **шаблонные классы**
```cpp

// напишем к примеру свой unique_ptr для любых типов данных
template <typename T>
class UniqPtr {
public:
	explicit UniqPtr(T* ptr) : ptr_(ptr){};

	T& operator*() {
		...
	}

	T* operator->() {
		...
	}

	~UniqPtr() {
		delete *ptr_;
	}

private:
	T* ptr_ = nullptr;
}


int main() {
	UniqPtr<int> ptr(new int(123));
	std::cout << *ptr << std::endl;
}
// можно не указывать тип, если компилятор понимает что мы передаем

UniqPtr ptr(new int(123)); // - в конструкторе явно понимается что есть T

// если же написать к примеру пустой конструктор и его запускать, то это уже не сработает


UniqPtr<int> ptr(new int(123));
UniqPtr<double> ptr(new double(123));
создатся два класса: для int и double
```

### **шаблон-метод-класс-шаблон**
```cpp
// теперь хотим шаблонный метод внутри шаблонного класса
template <typename T>
class UniqPtr {
public:
	explicit UniqPtr(T* ptr) : ptr_(ptr){};

		T& operator*() {
		...
	}

	T* operator->() {
		...
	}

	template<typename R>
	R Cast() const {
		return static_cast<R>(*ptr_);
	}

	~UniqPtr() {
		delete *ptr_;
	}

private:
	T* ptr_ = nullptr;
}

// такие методы генерятся отдельно от класса, так как при создании класса не понятно чему равен R
```

### **специализация шаблона**
```cpp
// хотим для стринга сделать свой собственный шаблон, такой к примеру
auto Sub(std::string a, std::string b) {
	return a.size() - b.size();
}

// тогда используем вот такой синтаксис
template <>
auto Sub<std::string>(std::string a, std::string b) {
	return a.size() - b.size();

// этот шаблон полная специализация более общего шаблона, поэтому идти должен позже

// конкретно в этом случае можно было и просто функцию бахнуть без специализации

// на классах интереснее

// к примеру 

template <typename T>
class UniqPtr {
public:
	explicit UniqPtr(T* ptr) : ptr_(ptr){};

	T& operator*() {
		...
	}

	T* operator->() {
		...
	}

	template<typename R>
	R Cast() const {
		return static_cast<R>(*ptr_);
	}

	~UniqPtr() {
		delete *ptr_;
	}

private:
	T* ptr_ = nullptr;
}


template <typename T>
class UniqPtr<T[]> { // акцентирую тут внимание
public:
	explicit UniqPtr(T* ptr) : ptr_(ptr){};

	T& operator*() {
		...
	}

	T* operator->() {
		...
	}

	template<typename R>
	R Cast() const { // хороший вопрос насколько корректно будет работать этот метод
		return static_cast<R>(*ptr_);
	}

	~UniqPtr() {
		delete[] *ptr_; // и тут можно в целом
	}

private:
	T* ptr_ = nullptr;
}
// да-да-да мы написали специализацию для массивов, как вам такое


int main() {
	UniqPtr ptr(new int(123));
	UniqPtr ptr(new int[5]);
}
// таким образом мы сделали свой умный указатель

// да, приходится писать по два раза функции и в теории можно было бы вынести общее в какой-то общий класс

// но а вдруг нам для массивов надо было бы писать совсем другое
```


### **много аргументов (очень!!!)**
```cpp

// вот так мы создаем шаблон на неограниченное количество элементов
template <typename T, typename... Args>
UnitPtr<T> MakeUniq(...) {
	
}
// это нам нужно, чтобы нормально передавать конструкторы для всех типов

template <typename T, typename... Args>
UnitPtr<T> MakeUniq(Args... args) {
	return UniqPtr<T>(new T(args...));
}

auto ptr = MakeUniq<std::vector<int>>(100);

std::cout << ptr->size();




auto ptr2 = MakeUniq<std::tuple<int, double, std::string>>(100, 0.9, "hello");

// tuple примерно так и реализован, только через рекурсию от size() - 1
!!! УПРАЖНЕНИЕ НАПИСАТЬ ТАКОЙ КЛАСС))
```


```cpp

// если в единице трансляции используется шаблон, этот шаблон должен быть в этой единице трансляции

// поэтому обычно шаблоны пишут в .h

// для облегчения жизни можно писать
typedef std::vector<int> vec1;
using vec2 = std::vector<int>;


// но using можно с шаблонами юзать
template<typename T>
using vec2 = std::vector<T, std::allocator<T>> // к примеру


// использовать

vec2<int> // - очень удобно использовать как alias
```

```cpp
когда мы пишем auto применяется тот же самый механизм как и для шаблонных параметров
```