# Контейнеры

std::array 
```cpp
std::array<int, 3> numbers = {1, 2, 3};
```

В отличие от сишного массива, его передача в функцию даст не указатель, а сам массив.


## std::list

Двусвязный список: каждая нода ссылается на следующую и предыдущую ноду.

> доступ к элементу O(n)
> зато удаление (при уже найденной ноде) O(1)
> у итератора листа нет +=, только ++it, --it, !=


## std::forward_list

> тот же лист только без ссылок назад, соответственно нет --it


```cpp
for (auto it = numbers.begin(); it != numbers.end(); ++it) {
	if (*it % 2 == 0) {
		numbers.erase(it);
	}
}
// после удаление начнем указывать на невалидный итератор

for (auto it = numbers.begin(); it != numbers.end();) {
	if (*it % 2 == 0) {
		it = numbers.erase(it); // erase возвращает следующий элемент
	} else {
		++it;	
	}
}
```


## std::deque

> deque - список векторов, он хранит несколько буферов
> достаточно эффективное обращение по индексу
> достаточно эффективная вставка, удаление из середины


# struct

## point

```cpp
void PrintPoint(int x, int y) {
	std::cout << x << " " << y << std::endl;
}
```

когда в функцию идет очень много параметров это чревато доп работой, так как нужно запоминать в каком порядке что идет, для решение данной проблемы есть struct
```cpp
struct Point{
	int x;
	int y;
}

void PrintPoint(const Point& point) {
	std:: cout << point.x << " " << point.y << std::endl;
}

Point point{10, 20}; // x - 10, y - 20
PrintPoint(point);
```

если не инициализировать поля примитивных типов, они заполняются мусором

1) инициализировать поля в самой структуре 
```cpp
struct Point{
	int x = 0;
	int y = 0;
}
```

2) фигурные скобочки
```cpp
Point point{10, 20}; // те, что мы не проинициализировали заполняются дефолтными значениями
```

3) начиная с 20 старндарта можно делать так
```cpp
Point point{.x=10, .y=20};

Point point{.x=10, 20}; // смешивать нельзя

Point point{.y=10, .x=20}; // так тоже нельзя

Point point{.x=10}; // y - дефолтное значение
```


## std::pair

```cpp
std::pair<std::string, int> pair{"hello", 10};
std::cout << pair.first << std::endl;
std::cout << pair.second << std::endl;
```

Создать:
```cpp
auto pair = std::make_pair("hello", 10);
```

## tuple

pair на максималках
```cpp
std::tuple<std::string, int, double> tuple{"hi", 10, 1.5};
std::cout << std::get<0>(tuple) << std::endl;
```

```cpp
int x = 10;
int y = 20;
auto tuple = std::tie(x, y); // создает тупл из ссылок
```


Разборка:
structured binding
```cpp
	std::pair<std::string, int> pair{"hi", 10};
	auto [word, number] = pair;
	// ==
	auto tmp = pair;
	std::string& word = tmp.first;
	std::string& number = tmp.second;
	// избежим копирование если напишем auto&[]
	// а еще есть const auto&[];
```


# ассоциативный контейнер

std::map
```cpp
std::map<std::string, int> map;
map["hi"] // ссылка на значение по ключу
// если ключа не было, он создаст ключ

// если const map, то [] работать не будет
map.at("hi"); // если есть ключ он его кидает, иначе кидает исключение
```


Инит мапы

```cpp
std::map<std::string, int> map{{"hi", 10}, {"bye", 20}};
// по факту мап хранит pair элементов

for (const auto& pair : map) {
	std::cout << pair.first << " " << pair.second << std::endl;
}
// ==
for (const auto& [key, value] : map) {
	std::cout << key << " " << value << std::endl;
}
```


Как устроен мап?

Мап устроен как красно-черное дерево, такое бинарное дерево поиска, что высота в нем примерно log. Соответственно все операции делаются за log

```cpp
auto it = map.find("hi");
if (it != map.end()) {
	it->second = 20;
}
// ==
if (auto it = map.find("hi"); it != map.end()) {
	it->second = 20;
}
```

Как не надо писать:
```cpp
if (map.contains("hi")) {
	map["hi"] = 20;
}
// предыдущий код в два раза быстрее
```

Вставка:
```cpp

auto [it, inserted] = map.insert({"world", 100});
// it - итератор на вставленный элемент
// inserted - новый элемент или такой уже был(1 - новый, 0 - старый)
```

++
```cpp
++it - за O(1)
обход за O(n)
```

## set

```cpp
std::set<int> set{1, 2, 3};
```

на ключах должна задача операция сравнения

> a(x, y) <-> !a(y, x)
> a(x, y) & a(y, z) -> a(x, z)
> e(x, y) = !a(x, y) & !a(y, x)


## unordered_map

> хэш таблица имеет саму таблицу и хэш функция
> x == y -> hash(x) == hash(y)
> x != y -> P(hash(x) == hash(y)) ~ 1 / max_size_t
> таблица делает так, чтобы кол-во коллизий было минимально

## unordered_set
он есть
