# Препроцессор

Немного о том что такое препроцессор и с чем его едят.

> команды решетка это комманды при препроцессоре. их обрабатывает программа до компилятора, он обрабатывает все эти макросы, а потом дает их компилятору. 

## **include**

> самая классическая команда, это конечно `include`
> 
```cpp

// для наглядности пусть string.h выглядит так:
string.h {
	// some code
	// some functions
	// etc.
}
// а наш cpp файл так:
main.cpp{
	#include <string>

	int main() {
		std::string s = "ДОРА ТОП 1";
		while (true) {
			std::cout << s << std::endl;
		}
	}
}
```
> так вот, что же делает препроцессор?
> 
> он берет смотрит на этот инклюд, и начинает искать файл с таким названием. Если он его находит, он вставляет содержимое этого файла вместо строки `#include sth`. То бишь наш код получится таким:
```cpp
main.txt /*(я так и не понял какое расширение имеет файл, но думаю пофиг)*/ {
	// some code
	// some functions
	// etc. 
	
	// сверху просто вставилось содержимое string.h
	
	int main() {
		std::string s = "ДОРА ТОП 1";
		while (true) {
			std::cout << s << std::endl;
		}
	}
}
```

> для супер любознательных: команда `g++ -E main.cpp` выведет в консоль содержимое этого самого обработанного препроцессором файла `main.txt`.

> (пссс чтобы вывести в отдельный файл нужно дописать `> out.txt`)
> copyfree: 
```bash
g++ -E main.cpp > out.txt
```

## **пишем свой хедер**

```cpp
print.h {

	void Print(const string& str) {
		cout << str;
	}
}

main.cpp {

	#include "print.h"
	// все будет работать так, будто эта функции стоит в main.cpp
	// так как содержимое h-файла просто вставится в cpp
}
```

> треугольные скобки обозначают, что файлик находится в стандратной библиотеке
> 
> кавычки соотвественно в локальной, но если тут не найдется, он пойдет искать в стандартной

> пжешка пишите те скобки, которые именно подразумеваются, это увеличит читаемость кода и прочее десятое


## **бахнем рекурсию?**

> не выйдет
```cpp
print2.h {
	#include "print.h"
}
print.h{
	#include "print2.h"
}
```
> не понятно насколько долго это будет копироваться вставляться и прочее, но умное препроцессоры выдадут ошибку.
> даже если каким-то образом это вставится 100 тысяч раз (и еще 2 миллиона на подходе), код просто-напросто не скомпилится, так как функции будут определены несколько раз.

## **pragma once**

> сильная и независимая. что она делает?
```cpp
#pragma once 

// такая штука скажет, что мы этот файл инклюдим только один раз
// то есть во второй раз это уже не инклюднится
```

> можно/нужно написать `pragma once` самому:
```cpp
#ifndef PRINT_H // если такой переменной нет
#define PRINT_H // создадим такую переменную

// your code goes here...

#endif // выйдем из ифика

// это все на уровне препроцессора, так как опять таки комманды "#" относятся к нему

```
> препроцессор зайдет в хедер копипастнет его, и инитнет препроцессорную переменную, когда ему понадобится вставить код второй раз он вставит пустоту, так как не зайдет уже в `ifndef`.

> зачем так писать? 
> ну, pragma once вообще может не существовать на чайнике с функцией жопа, поэтому там такой код может не сработать, а вот старый добрый `ifndef + define + endif` работает везде.

> *замечание автора*
> 
> в хедерах стандартной библиотеки стоит как раз таки `ifndef + define + endif`. Не утверждаю, что во всех, я глянул только парочку. 
> 
> чисто такой прикол, что в `clion`, если зажать `ctrl` или `alt` (точно не помню) и нажать на что угодно, тебя кинет в место, где это написано, соотвественно если нажать таким образом на `string` в `#include <string>` можно почитать там увлекательный код.


## **define**

> дефайн это по факту просто подстановка текст, грубо говоря `replace` в коде
``` cpp

main.cpp{
	#define ONE 1
	...
	std::cout << ONE << std::endl;
}

main.txt{
	// nothing
	...
	std::cout << 1 << std::endl;
}
// он просто на этапе обработки подставит вместо ONE 1 и дело сделано.
```

> а еще вот так (просто мем)
```cpp
main.cpp{
	...
	#define ONE // инитим ONE

	#ifdef ONE // если ONE есть, то
	HELLO
	#endif // кончился ифик
	...
}

main.txt {
	...
	// пусто
	HELLO
	// пусто
	...
}
// и да это просто не скомпилится
```

> Использовать `define` плохая практика
> НО!:
> это требуется для написания сложного кросс-платформенного кода
> к примеру, пишем мы `brawl stars.exe` на яблоко и андройд, а у них разные функции для вывода картинки на экран, ну тогда мы просто ифаем, что если мы на яблоке, то выводим так, а если на андройде, то по-другому.


## **всякие встроенные макросы**
```cpp
__LINE__ // - говорит на какой строчке

__FILE__ // - название файла

__DATE__ // - This contains a string of the form month/day/year that is the date of the translation of the source file into object code.

__TIME__ // - This contains a string of the form hour:minute:second that is the time at which the program was compiled.

// да я украл, но мне можно
// https://www.tutorialspoint.com/cplusplus/cpp_preprocessor.html
```

## еще немного об include
> инклюдить файлы по два раза: в `cpp` и в `.h` - не прикольно. 
> так что есть золотое правило:
> в .h пиши все что нужно, но по минимуму или к тебе ночью придет Бьёрн Страуструп и заберет подписку на `clion`. Подробнее об этом в следующей части подпишись на канал чтобы на забыть! Лан ща расскажу.


## **Единица трансляции**

> Каждый `cpp`-шный файл это одна единица трансляции. Что это и для чего нужно?

> Каждая единица трансляции компилится независимо. Когда у вас один `cpp` файл в целом на это пофиг, поредачили какой-либо файл и заново все перекомпилили.

> А теперь представим огромную компанию где 1337 `cpp` файлов, миллиарды строчек кода и всего прочего, а вы маленький неприметный `HELLO_WORLD`, который просто хочет вывести строчку. Если каждый раз компилить всю эту электронную биомассу, получится адское время ожидания. 

> Поэтому придумали компилить каждый `cpp` файл независимо, а потом их объединять с помощью `LINKER`. Соотвественно в этой жизни `cpp` Микки Маус, а `.h` файлы просто его подручные.

> В итоге у нас 4 фазы:
> 1) для каждого `cpp` файла пихнуть все, что юзается в один большой файл
> 2) для каждой биомассы скопмилить это
> 3) объединить между собой скомпиленных челов
> 4) выдать запускаемый файл

> В общем-то говоря, если мы меняем какой-то `.h` файл, нам очевидно надо перекомпилить всех челов, которые на него ссылаются. Если мы меняем `.cpp` файл, нам только его надо менять. 

> Поэтому писать в `.h` нужно минимум, к примеру:
```cpp
... // - все что нам надо инклюднуть

class Mem; // - всякие структурки, которые мы потом будем юзать

class Memes {
	void FunnyMemes(vector Memes); //- в самих структурах функции, но опять таки без тела
	int memes_counter_; // - поля классов и тд
}
```
> то есть в `.h` надо писать все, но минимально, только дать понять, что у нас все это как бы есть или будет, но ничего конкретно не реализовывать, чтобы потом спокойно переписать те `cpp` файлы, где у нас реализована та или иная вещь, и рекомпилить только их

> обычно в хедерах сначала пишут стандартные библиотеки, а в плюсах наоборот, сначала наши библы, чтобы все нужные библиотеки подсасывать у хедеров.