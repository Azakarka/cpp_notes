# Операторы


## **Конструктор копирования**
```cpp
struct Vector {
	Vector() {
	}

private:
	vector<int> values_;	
};


Vector vec1;
Vector vec2 = vec1; // <- тут копируется объект vec1 в vec2

// такая штука как не сложно догадаться называется конструктором копирования
```

> как написать свой такой же?
> 
```cpp

Vector(const Vector& other) {
}

// он принимает константную ссылку на объект того же класса, а потом копирует все поля

// можно написать свое копирование
// или все что угодно, это ведь точно такой же метод, как и все остальные
Vector(const Vector& other) {
	values_ = other.values_;
}
```

```cpp
// также контструктор копирования вызывается и при такой записи

Vector vec1;
Vector vec2(vec1);
```


## **Оператор присваивания**

```cpp
Vector vec1;
Vector vec2;
vec2 = vec1;

// тут уже не вызывается конструктор копирования
// объект уже создан и у него есть какие-то значения, ему их просто надо обновить
```

```cpp
??? operator=(const Vector& other) {
}

// - синтаксис оператора присваивания


// подумаем, что же должно быть вместо ???

// в плюсах есть такой прекрасный синтаксис как
x_1 = x_2 = x_3

// который выполняется как
x_1 = (x_2 = x_3)

// соотвественно когда мы присваиваем какой-то штучке, хочется чтобы потом кому-то можно было присвоить уже его. 
// а значит возвращаем ссылку на объект

// все по фэншую
Vector& operator=(const Vector& other) {
	values_ = other.values_;
	return *this;
}
```

> в `??? operator=(const Vector& other);`
> вместо `???` может стоять все, что угодно, однако мы хотим поддерживать семантику языка, поэтому возвращаем ссылку


```cpp
// возникает закономерный вопрос, если мы на вход берем константную ссылку, то почему отдаем обычную?

// очень просто, иногда хочется сделать вот так

(vec1 = vec2).do_sth();

// соотвественно если метод не константный, то и вызвать у нас ничего не получится

// + просто так пишут и так удобнее
// лучше не возвращать конст ссылку (у меня clion даже ругается на такое)
```

 > что еще хорошо было бы дописать?

```cpp
// Иногда может случиться такое, что:
vec2 = vec2;

// как правило мы не хотим, чтобы эта штука что-то меняла, поэтому пишем

Vector& operator=(const Vector& other) {
	if (this == &other) {
		return *this;
	}
}
```


## **default & delete**

> что ж, мы написали свои операторы присваивания и конструкторы копирования, но почему когда мы этого не делаем, всё все равно работает?

> а потому что компилятор умный и сам за нас пишет эти дефолтные штуки

> *так когда надо писать свой, а когда надо оставлять работу компилятору?*

```cpp
// очень просто 
// если у вас нет чего-то сложного в классе, к примеру у вас просто вектора, инты, строки, мапы и тд - то есть то, что легко и понятно копируется, то лучше оставить это все компилятору
class Easy {
	int easily = 0;
	vector<double> trivial;
	map<int, string> apparent;
	...
}
// компилятор сам все легко скопирует.

// !!!НО!!! 
// если у вас собственно ручное выделение памяти (которое напомню нужно чистить самому) или какие-то указатели или еще что-то - в общем все, что может скопироваться плохо, то надо писать самому
// Наглядный пример:
class Vector {

	Vector() {
		arr = new int[50];
	}

private:
	int* arr;
}

// если юзать дефолтное копирование, то у нас тупо скопируется ссылка и у двух разных объектов будет один и тот же массив!!!
```

```cpp
// Чтобы компилятор лишний раз не баловался, можно запретить создавать ему дефолтные штуки, к примеру

Vector(const Vector& other) = delete; 
// запретит ему создавать дефолтный конструктор копирования.

// то же самое можно и с = сделать (да вроде с чем угодно)
Vector& operator=(const Vector& other) = delete;
```

> *получается лучше всегда на всякий случай писать свои штучки?*

> нет, если в классе не подразумевается что-то такое, что неправильно копируется, лучше оставлять все компилятору. Почему? 
> 1) Когда добавляете новую переменную, можете забыть ее проинициализировать в конструкторе и пиши-пропало, а вот машина не забудет
> 2) Тупо меньше кода. Зачем много кода, когда можно мало кода?

## **Правило 0 и 3(5)**

> 3(5): если мы написать деструктор или оператор присваивания или конструктор копирования - нам нужно написать и два других. С `c++11` на самом деле это правило 5, так как там добавляется штучка `move`. 
> правило используется если у нас есть какое-то владение ресурсом или нетривиальное копирование.

> если у нас все с копированием хорошо, у нас какие-то понятные объекты, используем правило нуля, то есть оставляем все дефолтным.

# **Дальше про операторы**

```cpp
// когда мы делаем какое-нибудь
Vector vec1;
Vector vec2;
vec2 = vec1

// на самом деле выполняется
vec2.operator=(vec1) 
// что еще раз показывает, что операторы это просто методы
vec2 = vec1 // - просто является синтаксическим сахаром
```

> Несколько моментов про перегрузку:
> 1) нельзя ввести новые операторы (к примеру "#", "@")
> 2) нельзя перегружать "::", ".", "?:"(тернарный), а -> можно
> 3) приоритет сохраняется, то есть "*" будет вызвана раньше "+" и тд


## **Операторы сравнения**

> Начнем с базы - с " == "
```cpp
bool operator==(const Vector& other) const {
	return vec.size() == other.size();
}
// возвращаем естественно булинчик, в полях у нас другой такой же объект, а еще сигнутура функции имеет const.

// то есть этот оператор вызывается при
vec1 == vec2 // = (vec1.operator==(vec2))


// Интересный факт, что с какого недавнего старндарта плюсов (17 или 20), если мы сделали ==, то компилятор за нас автоматически сделает != (если мы конечно сами его не написали). В обратную сторону не работает.
```

> Что ж, но чтоб сравнивать что-то нам нужно ну уж очень много чего писать, это и "<" и ">" и " == " и '"<=" и еще пару штук. Неудобно, поэтому с `c++20` появился этот рыбокит.

## **spaceship (<=>)**

```cpp
auto operator<=>(const Vector& other) const {
}

// вообще auto может быть weak_ordering, strong_ordering и partial_ordering, но это уже что-то сложное

// как он работает?
// как и с strcmp, он выводит число меньше 0, если левый объект меньше, больше нуля если больше и 0 при равенстве.

std::cout << (vec1 <=> vec2 == 0) << std::endl; 
// выведет равны ли строки

// эту штуку можно делать дефолтом

auto operator<=>(const Vector& other) const = default;

// ну или реализовать как-то

auto operator<=>(const Vector& other) const {
	return vec.size() - other.vec.size(); 
	// ну такое по факту может сломаться так как size_t >= 0
}
```

```cpp
// так почему спейсшип удобен? На основе spaceship компилятор сделает дефолтные операторы для всех сравнений. 

// auto operator<=>(const Vector& other) const = default;

vec1 <= vec2
// эквивалетно
vec1 <=> vec2 <= 0

// !!!НО!!! не == (и не != соотвественно)
// == дефолтно не создается, так как почти всегда == можно сделать оптимальнее чем обычное сравнение, поэтому язык не позволяет прогерам писать неэффективный код.
```

```cpp
// также как факт можно реализовать каждое сравнение ручками, комплятор не будет создавать дефолтный, если вы зададите свой сами
bool operator<(const Vector& other) const { // при < будет вызываться этот
	return random();
}

auto operator<=>(const Vector& other) const = default;
```

## **релизуем ПРОСТОЕ сложение**

```cpp
// пусть мы хотим написать что-то такое

vec1 = vec2 + 100;

// тогда просто напишем
Vector operator+(int mem) const {
	Vector new_vector = *this;
	...;
	return new_vector;
}
// Мы не хотим менять исходный объект, поэтому не забываем const

// мы делаем копирование, потому что если возвращать ссылку, объект уже умрет, так как он локальный, поэтому приходится копировать.

// вроде все легко, ну а что если

vec2 = 100 + vec1;
// перепишем класс int (при условии что он примитив)?

// НОУП, это дело для больших дяденек
```


## **операторы-функции**

> можно сделать оператор-функцию вне класса

```cpp
Vector operator+(int mem, const Vector& vec) {
	Vector new_vector = vec;
	// ...
	return new_vector;
}

// И да, без friend мы не будем иметь доступ к приватным материалам
// но никто не мешает навесить friend на эту функцию-оператор
```

## **инкремент**

```cpp
Vector& operator++() {
	...
	return *this;
}
// как мы знаем префиксный ++ увеличивает значение на 1 и возвращает ссылку на новое значение, чем мы и занимаемся)
++vec1; // - сработает

++++++++++vec1; // - по секрету даже это сработает опять таки потому что мы возвращаем ссылку

// что насчет постфиксного? тут надо написать костылик чисто для компилятора
Vector operator++(int) { // да просто написать int
	Vector old_vec = *this;
	// ...
	return old_vec;
}

// понятно, чтобы нам вернуть старый объект его нужно скопировать и уже отдать не по ссылке, ведь он локальный
```


# **пошел какой-то обман**

> Какие-то фантастические фокусы

```cpp
// мы хотим сделать чтобы наша штука неявно к чему-то приводилась

// то есть в прошлой записи мы убирали, чтобы какая-то штука становилась нашей, а сейчас хотим колдовать над своей

// ПРИМЕР:
if (vec1) { // хотим чтоб давал тру если вектор не пустой
}


// для таких выкрутасов нам дали возможность написать

operator bool() {
	return !vec.empty();
}
// заметим, что перед оператором ничего нет, потому что и так понятно что мы выведем, ведь это написано после
```

```cpp
// теперь можно писать

bool b = vec1;

// но обычно мы не хотим чтобы вектор неявно приводился к булу, так как где-то как-то случайно не то не там сделаем, передадим не бул, а вектор и тд и тп.

// поэтому сделаем explicit аче нам)
explicit operator bool() {
	return !vec.empty();
}

теперь bool b = vec1; не сработает

// вопрос нафиг надо? Ну, во-первых для булинчиков если исключение в виде
if (vec1) {
	// он продолжит компилиться
}

// а во-вторых все еще можно делать так

bool b = static_cast<bool>(vec1);
// так что жизнь не так уж и ужасна
```

## **Концовку слили**

> да лан шучу, все еще вкусно

```cpp
// хотим чтоб вот так вот пжпжпжпп

std::cout << vec1 << std::endl;

// видим (замечаем), что не получится написать что-то типа
operator<<(){
	// do sth
}
// просто потому что слева у нас cout, а не наш чел

// поэтому как и в примере с 100 + vec1 нам надо сделать отдельную функцию

std::ostream& operator<<(std::ostream& stream, const Vector& vec) const{
	stream << vec.size;
	return stream;
}

// опять таки возвращаем ссылку, так как хотим, чтобы такое работало 
std::cout << 228 << 1337 << vec << "abacaba" << ...;
// то есть это по факту просто последовательное выполнение операторов, в этом плане << никак не отличается от других операторов.

// ну и понятно, делаем это вне класса, а если хотим чтобы юзались приватные поля дружимся через friend
```