# **AUTO (хендай)**

> В плюсах есть ключевое слово `auto`

> Компилятор сам определяет тип переменной:
```cpp
auto i = 10;
// компилятор определит что тут за тип и в runtime будет
int i = 10;

// еще примеры
auto i = 1ll; // long long i = 1ll;
auto d = 1.1; // double f = 1.1;
```

> Тип auto удобно юзать для типов с очень длинным названиями
> Также код будет более адаптивный
```cpp
// было
int foo() {
	return 10;
}
int mem = foo();
// стало
long foo() {
	return 10;
}
long mem = foo();

// если бы мы написали
auto mem = foo();
// нам бы не пришлось менять int на long для mem
```


## *auto с ссылками*
```cpp
int i = 0;
int& i_ref = i;
auto j = i_ref; // j - int
auto& j = i_ref; // j - int&
const auto& j = i; // j - const int&
```

## *траблы с auto*
```cpp
auto GetNumber() {
	int* i = nullptr;
	if (true) {
		return i;
	}
	return nullptr;
	// такая штука не скомпилится
	// потому что nullptr это отдельный тип данных
	// мы выводим два разных типа данных и он не знает какой брать
	// нужен либо static_cast либо выводить не auto, а int*
}
```

# **Массивы**
```cpp
	int numbers[3]; // база задачи массивов
	// создаст массив длиной 3
```

> Изначально заполнен мусором
> 
> можно делать так:
> int numbers[3] = {1, 2, 3}
> 
> int numbers[3] = {1, 2}
> заполняет заданные, а хвост нулями
>  
> int numbers[3] = {}
> все нулями

```cpp
int numbers[3] = {1, 2, 3};
int* numbers_ptr = numbers;
// напомню: *(numbers_ptr + i) == numbers[i]
```

## *передача массивов*
```cpp

void Print(int numbers[3]) {
	std::cout << sizeof(numbers); // выведет sizeof(int)
}
// массив передается как указатель, то есть вышенаписанное ==
void Print(int* numbers) {
	std::cout << sizeof(numbers);
}
```

> получатся что int[] = int*, то есть для указателей заданы квадратные скобочки
> int * numbers;
> numbers[3]

> массив по факту передается по ссылке, так что с ним нужно аккуратно работать в функции

> Двойные массивы
```cpp
// то есть массив ссылок (которые тоже являются массивами)
int numbers[2][3] = {{}, {}};
```

# **Строки**

```cpp
std::string str = "hello";
// и
std::cout << "hello" << std::cout;
// это разные штуки

// второй cout имеет тип const char* (указатель на чар)
const char* str = "hello";
// то есть стандартный сишные строки
```

> при инициализации char* в конец ставит \0
> при обращении идет читает с первого элемента пока не найдет нулевой элемент
> поэтому если взять указатель дальше строки, он будет бежать далеко до первого \0

```cpp
char* str = "hell\0o";
// выведет hell
```

> как можно заметить C-строки не очень-то и удобные 
> потому, что они "голые", то есть чисто сырые указатели

```cpp
// к примеру нельзя сделать так
std::cout << "Hello " + " world" << std::endl;

// вот тут он будет сравнивать просто два указателя, а не содержимое
if ("hi " < "hello"){}

#include <cstring>
// можно сравнить так
if (strcmp("Hello ", "world") == 0) {}
// 0 - равно, < 0 - первая больше, иначе вторая
```

```cpp
#using namespace std::literals;
if ("Hello "s == " world"s)
// такой литерал привращает const char* в std::stirng
```

> можно сделать свой литерал, е слову


# **нормальные строки std::string**

```cpp
// уже имеет нормальный функционал
// умеет всякое разное полезное
std::string str = "hello";

str.c_str(); // дает char* 
str.data(); // делает по факту тоже самое, но еще и сделан под вектор(для шаблонов)
str.find("ll"); // возвращает индекс первого вхождения


string str = to_string(10);
stoi(), stol(), stoll() // - превращает строку в int, long, long long соответственно
```

## *Векторинки*
```cpp
std::vector<int> numbers = {1, 2, 3};
```
> вектор устроен так:
> имеем массив, где хранятся элементы, `capacity` (размер занятого места) и `size` (сколько элементов в векторе)
> когда `size` становится больше `capacity`,  создается новый массив, вдвое большей длины (`capacity` тоже меняется), старые элементы перекидываются в новый массив, старый массив удаляется.

> если смотреть дальше нужного, то есть `numbers[numbers.size()]`, то будет либо `undefined behaviour` либо `SIGSEV`

> есть `numbers.at(i)` который с ификом проверяет не вышли ли мы за вектор


## **Итераторы**

> итератор - удобный указатель, по которому удобно итерироваться
```cpp
auto it = numbers.begin();
auto it_end = numbers.end(); 
// end невключительно


// операции
*it //разыменовывание итератора
++it или it++ // след итератор 
--it // предыдущий (у некоторых нет, к примеру у односвязного списка)

++it // возвращает новое значение
it++ // возвращает копию старого, меняет старое
// он менее эффективнее из-за всяких копирований, поэтому лучше юзать префиксный ++

// а вот чем удобен итератор:
// такой код (проход по вектору)
for (auto it = numbers.begin(); it != numbers.end(); ++it) {
	int n = *it;
	std::cout << n << std::endl;
}
// тоже самое что и
for (int n : numbers) {
	std::cout << n << std::endl;
}
// видно что элементик-то копируется, поэтому можно поставить ссылочку, а еще лучше константную
for (const std::string& s : strings) {
	std::cout << s << std::endl;
}
// теперь счастье эффективности
```