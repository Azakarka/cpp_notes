# *с чем кушают функции*

> Функции видят только те функции, которые заданы перед ними
> 
> Поэтому надо ее заранее задать:
```cpp
// мы можем просто объявить функцию, без определения
void foo1();

void foo2() {
	foo1();
}

void foo1() { // - определяем объявленную функцию
	foo2();
}
```


> При объявлении можно не писать названия параметров, но это плохая практика
```cpp
// так можно
void foo(int, long, unsigned);

// но так лучше
void foo(int mem, long kek, unsigned lol);
```


> Правила функций:
> 1. делать одно дело и делать это хорошо
> 2. одинаковый уровень абстракции

> первое правило понятно: разделяем код на функции, чтобы было легче дебажить, лучше читался код и не повторялись отдельные элементы

> теперь разъясняю второе правило
```cpp
int main() {
	int value;
	std::cin >> value;
	std::cout << CalcFactorial(value) << std::endl;
}
// мы вводим/выводим и делаем что-то высокоуровневое в одной функции main
// лучше выделить для ввода/вывода отдельную функцию

// так что пишем что-то такое:
int ReadInput() {
	int sth;
	std::cin >> sth;
	return sth;
}

void PrintResult(int val) {
	std::cout << val << std::endl;
}

int main() {
	int input_value = ReadInput();
	int result = CalcFact(input_value);
	PrintResult(result);
}
// так писать намного лучше
// здесь мейну не важно как мы считываем, считывание может даже поменяться
// так что такой код легко поддерживать
// + к читаемости
```


# **Const или не const**


> заметим, что в предыдущем коде мы никак не меняем наш `input`, так что имеет смысл сделать его `const`
```cpp
int main() {
	const int input_value = ReadInput(); 
	int result = CalcFact(input_value);
	PrintResult(result);
}
```

> Facts:
> 1) const int - отдельный тип данных
> 
> 2) const никто не изменит - безопасность кода
> 
> 3) в const обычно записываетсю магические строчки/чиселки

```cpp
// вместо
int main() {
	for (int i = 0; i < 32; ++i) {
		std::cout << (1 << i) << std::endl;
	}
}

// лучше написать 
const int bit_cnt = 32;

int main() {
	for (int i = 0; i < bit_cnt; ++i) {
		std::cout << (1 << i) << std::endl;
	}
}

// так как количество бит может поменяться, и нам придется во всех местах менять 32 на, к примеру, 16
// + к читаемости, ведь не всегда очевидно что такое 32 и прочее
```

# **Ссылочки**

```cpp
// когда мы пишем вот так
void foo(int mem) { // datatype var_name
	// у нас копируется объект
	mem = 10;
	// mem = 10 ничего не поменят для main::mem так как это другой объект
}

int main() {
	int mem = 3;
	foo(mem);
	std::cout << mem << std::endl; // выведет 3 не 10
}
```

> Если объект тяжелый имеет смысл передавать его по ссылке, чтобы не создавать его дупликат просто так

```cpp
// вот так уже не скопируется объект, а передастся по ссылке
void foo(int& mem) { // то есть локальная переменная foo::mem, на самом деле main::mem
	mem = 10;
}

int main() {
	int mem = 3;
	foo(mem);
	std::cout << mem << std::endl; // выведет 10
}
```

> int& - отдельный тип, указывающий на ту же ячейку памяти, что и объект, к которому он привязан
> ссылка на объект это по сути его синоним
> все действия над ссылкой будут производится над объектом


> очень круто будет если объединить ссылку и константу
```cpp
// к примеру
void foo(const std::string& s) {
	std::cout << s << std::endl;
}
// объект не копируется + мы не можем его изменять, чисто read-only

// к слову, конкретно для std::string для этого есть std::string_view
 ```

> с ссылками могут возникнуть траблы
```cpp
// попробуем написать так
int& foo() {
	int mem = 10;
	return mem;
}
```

> СТРАДАТЬ!!!!!!
> это нифига не сработает, потому что время жизни mem ограничено ее функцией
> в конце функции `foo` переменная `mem` умрет
> поэтому если мы вернем ссылку на мертвый объект, мы будет жестко страдать!!!!

```cpp
const int glob = 2;

int foo() {
	int mem = 10;
	return mem;
}
int main() {
	int mem = foo();
	// временный объект копируется в нормальный, после ";" временный умирает*
	
	const int& mem = foo();
	// так временный объект живет до конца скоупа
	
	int &mem = foo(); 
	// не сработает, потому что временный хранится в регистре процесcора, а не в норм памяти, которую мы можем менять
	
	int a = 10;
	int &mem = a;
	// уже сработает, так как переменная имеет имя, она не временная	
}

// * дальше вы пройдете move semantics, RVO, NRVO, inline, где на самом деле окажется, что при таких конструкциях ничего не копируется и переменная из функции сразу записывается в переменную из main, но это все потом
```

# **Указатели**

> указатель, это переменная, которая хранит адрес, по которому можно найти нашу переменную
> да похоже на ссылку, только скорее ссылка - это более удобный указатель
> нельзя поменять место, за которым прикреплена ссылка, однако указатель можно менять как хочешь

```cpp
datatype* name; // "*" - обозначение указателя

// к примеру
int* ptr;
int var = 3;
ptr = &var;
// здесь & - оператор взятия адреса
// ptr будет хранить просто адрес объекта var

std::cout << *ptr << std::endl; 
// а вот так получаем значение по этому адресу

std::cout << ptr << std::endl; 
// выведет адрес, то есть большое странное число
```

## *const*
```cpp
int value = 3;

// читаем справа налево

const int* ptr = &value; // указатель на константный инт
// через указатель нельзя менять value

int* const ptr = &value; // константый указатель на инт
// значение по указателю менять можем, сам указатель нет

const int* const ptr = &value; // константный указатель на константный инт
// ничего нельзя менять
```

```cpp
*input_ptr // - возвращает ссылку на объект

// поэтому 
int a = 0;
int* input_ptr = &a;
*input_ptr = 4;
// равносильно в этом мини-примере
int a = 0;
int& b = a;
b = 4;

// замечу, что указатель не на константную память, так что менять можем
```


# **Указатель на примере вектора**

```cpp
int main() {
	std::vector vec = {1, 2, 3, 4}
	int* vector_begin = v.data();
	// data() - выводит указатель на самый первый элемент вектора
}
```

> указатель вектора является random access указателем, то есть:
> 
> 1) брать элемент по индексу, а именно если `ptr_i` - указатель на `i`-ый элемент вектора и `index` - какое-то число, то `ptr_i + index` - указатель на позицию `i + index`
> 2) `ptr2 - ptr1` - количество элементов между двумя указателями (определена, если оба указателя на один непрерывный буфер указывают)
```cpp
// то есть
std::cout << vec[i] << std::endl;
// то же самое, что и
std::cout << *(vec.data() + i) << std::endl;
```